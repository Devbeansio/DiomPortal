{"ast":null,"code":"import _get from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _objectSpread from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _assertThisInitialized from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _asyncToGenerator from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"D:/diom working project/staging/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"D:\\\\diom working project\\\\staging\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty';\nimport _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty'; // Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\n\nfunction createElement(name) {\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var element = document.createElement(name);\n\n  for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        _name = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (_name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(_name, value);\n    }\n  }\n\n  var _iterator = _createForOfIteratorHelper(Array.isArray(children) ? children : [children]),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      element.append(child);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return element;\n}\n/**\n * Shared options for embedding\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createChart}.\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createDashboard}.\n */\n//TODO find a way to reuse types defined in \"packages/charts-frontend/src/utils/chart/events/event-payload-types.ts\"\n\n\nvar THEME_ENUM;\n\n(function (THEME_ENUM) {\n  THEME_ENUM[\"DARK\"] = \"dark\";\n  THEME_ENUM[\"LIGHT\"] = \"light\";\n})(THEME_ENUM || (THEME_ENUM = {}));\n\nvar SCALING_ENUM;\n\n(function (SCALING_ENUM) {\n  SCALING_ENUM[\"FIXED\"] = \"fixed\";\n  SCALING_ENUM[\"SCALE\"] = \"scale\";\n})(SCALING_ENUM || (SCALING_ENUM = {}));\n/**\n * Retrieve embed options that are shared.\n *\n * Validates the values passed in as well.\n */\n\n\nvar getSharedEmbedOptions = function getSharedEmbedOptions(options) {\n  var background = options.background,\n      baseUrl = options.baseUrl,\n      autoRefresh = options.autoRefresh,\n      maxDataAge = options.maxDataAge,\n      width = options.width,\n      height = options.height,\n      theme = options.theme,\n      showAttribution = options.showAttribution,\n      getUserToken = options.getUserToken;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  return {\n    background: background,\n    baseUrl: baseUrl,\n    autoRefresh: autoRefresh,\n    maxDataAge: maxDataAge,\n    width: width,\n    height: height,\n    theme: theme,\n    showAttribution: showAttribution,\n    getUserToken: getUserToken\n  };\n};\n\nvar getPathname = function getPathname(url, pathname) {\n  return [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', // Add trailing slash if not there\n  pathname].join('');\n};\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\n\n\nvar getChartUrl = function getChartUrl(options) {\n  try {\n    var url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/charts');\n    url.search = \"id=\".concat(options.chartId, \"&sdk=2\");\n\n    if (options.autoRefresh === false) {\n      url.search += \"&autorefresh=false\";\n    } else if (options.autoRefresh === undefined) {\n      url.search += options.refreshInterval ? \"&autorefresh=\".concat(options.refreshInterval) : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += \"&maxDataAge=\".concat(options.maxDataAge);\n    }\n\n    if (options.filter) {\n      url.search += \"&filter=\".concat(encodeURIComponent(EJSON.stringify(options.filter, {\n        relaxed: false\n      })));\n    }\n\n    if (options.theme) {\n      url.search += \"&theme=\".concat(options.theme);\n    }\n\n    if (options.showAttribution === false) {\n      url.search += \"&attribution=false\";\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/**\n * Constructs the dashboard iframe URL from the baseUrl, dashboardId & tenantId\n */\n\n\nvar getDashboardUrl = function getDashboardUrl(options) {\n  try {\n    var url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/dashboards');\n    url.search = \"id=\".concat(options.dashboardId, \"&sdk=1\");\n\n    if (options.autoRefresh === false) {\n      url.search += \"&autoRefresh=false\";\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += \"&maxDataAge=\".concat(options.maxDataAge);\n    }\n\n    if (options.showTitleAndDesc === true) {\n      url.search += \"&showTitleAndDesc=true\";\n    }\n\n    if (options.widthMode) {\n      url.search += \"&scalingWidth=\".concat(options.widthMode);\n    }\n\n    if (options.heightMode) {\n      url.search += \"&scalingHeight=\".concat(options.heightMode);\n    }\n\n    if (options.theme) {\n      url.search += \"&theme=\".concat(options.theme);\n    }\n\n    if (options.chartsBackground) {\n      url.search += \"&chartsBackground=\".concat(options.chartsBackground);\n    }\n\n    if (options.showAttribution === false) {\n      url.search += \"&attribution=false\";\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/*\n  Parses a CSS Measurement from an unknown value\n  - if it's a string, we trust that it is well-formed\n  - if it's a number, we assume the units are pixels\n  - otherwise we return null\n*/\n\n\nvar parseCSSMeasurement = function parseCSSMeasurement(value) {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return \"\".concat(value, \"px\");\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\n\nvar getBackground = function getBackground(background, theme, lightBackground, darkBackground) {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return darkBackground;\n  return lightBackground;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar BaseEmbedItem = /*#__PURE__*/function () {\n  function BaseEmbedItem() {\n    _classCallCheck(this, BaseEmbedItem);\n\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ERRORS\", void 0);\n\n    _defineProperty(this, \"COLOUR\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n  }\n  /**\n   * Renders an embeddable item into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the item has successfully been embedded\n   */\n\n\n  _createClass(BaseEmbedItem, [{\n    key: \"render\",\n    value: function () {\n      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(container) {\n        var embedRoot, host;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.iframe) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(this.ERRORS.IFRAME);\n\n              case 2:\n                // Create styled container\n                embedRoot = this._configureEmbedRoot(createElement('div', {\n                  style: {\n                    position: 'relative',\n                    overflow: 'hidden',\n                    minHeight: Boolean(this.options.height) ? 0 : '15px',\n                    width: parseCSSMeasurement(this.options.width) || '100%',\n                    height: parseCSSMeasurement(this.options.height) || '100%'\n                  }\n                })); // Create host\n\n                host = this._configureHost(Chatty.createHost(this.getEmbedUrl()).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot)).build(); // Customise IFrame styles\n\n                host.iframe.setAttribute('aria-label', this.name);\n                Object.assign(host.iframe.style, {\n                  position: 'absolute',\n                  top: 0,\n                  left: 0,\n                  border: 0,\n                  width: '100%',\n                  height: '100%'\n                }); // Remove any existing nodes in our target container\n\n                while (container.firstChild) {\n                  container.removeChild(container.firstChild);\n                }\n\n                container.appendChild(embedRoot); // connect to iframe\n\n                _context.next = 10;\n                return host.connect();\n\n              case 10:\n                this.connection = _context.sent;\n                this.iframe = host.iframe;\n\n                this._setBackground(this.options.background, this.options.theme); // configure token if needed\n\n\n                _context.next = 15;\n                return this._retrieveAndSetToken();\n\n              case 15:\n                _context.next = 17;\n                return this._send('ready');\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function render(_x) {\n        return _render.apply(this, arguments);\n      }\n\n      return render;\n    }()\n    /**\n     * @returns whether auto refreshing is enabled\n     */\n\n  }, {\n    key: \"isAutoRefresh\",\n    value: function () {\n      var _isAutoRefresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$_send, _yield$this$_send2, result;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._send('get', 'autoRefresh');\n\n              case 2:\n                _yield$this$_send = _context2.sent;\n                _yield$this$_send2 = _slicedToArray(_yield$this$_send, 1);\n                result = _yield$this$_send2[0];\n                return _context2.abrupt(\"return\", typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function isAutoRefresh() {\n        return _isAutoRefresh.apply(this, arguments);\n      }\n\n      return isAutoRefresh;\n    }()\n    /**\n     * Enable/Disable auto refreshing.\n     */\n\n  }, {\n    key: \"setAutoRefresh\",\n    value: function () {\n      var _setAutoRefresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(value) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(typeof value !== 'boolean')) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.reject('autoRefresh property value should be a boolean'));\n\n              case 2:\n                _context3.next = 4;\n                return this._send('set', 'autoRefresh', value);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function setAutoRefresh(_x2) {\n        return _setAutoRefresh.apply(this, arguments);\n      }\n\n      return setAutoRefresh;\n    }()\n    /**\n     * @returns the number of seconds before a chart or dashboard's data expires\n     */\n\n  }, {\n    key: \"getMaxDataAge\",\n    value: function () {\n      var _getMaxDataAge = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _yield$this$_send3, _yield$this$_send4, result;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._send('get', 'maxDataAge');\n\n              case 2:\n                _yield$this$_send3 = _context4.sent;\n                _yield$this$_send4 = _slicedToArray(_yield$this$_send3, 1);\n                result = _yield$this$_send4[0];\n                return _context4.abrupt(\"return\", typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMaxDataAge() {\n        return _getMaxDataAge.apply(this, arguments);\n      }\n\n      return getMaxDataAge;\n    }()\n    /**\n     * Set the number of seconds a chart or dashboard's data expires.\n     */\n\n  }, {\n    key: \"setMaxDataAge\",\n    value: function () {\n      var _setMaxDataAge = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(value) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof value !== 'number')) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", Promise.reject('maxDataAge property value should be a number'));\n\n              case 2:\n                _context5.next = 4;\n                return this._send('set', 'maxDataAge', value);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function setMaxDataAge(_x3) {\n        return _setMaxDataAge.apply(this, arguments);\n      }\n\n      return setMaxDataAge;\n    }()\n    /**\n     * Sets the color scheme to apply to the chart or dashboard.\n     *\n     * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n     */\n\n  }, {\n    key: \"setTheme\",\n    value: function () {\n      var _setTheme = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(value) {\n        var newTheme;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof value !== 'string')) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", Promise.reject('theme property value should be a string'));\n\n              case 2:\n                // if invalid theme string is provided, default it to light\n                newTheme = Object.values(THEME_ENUM).includes(value) ? value : THEME_ENUM.LIGHT;\n                _context6.next = 5;\n                return this._send('set', 'theme', newTheme);\n\n              case 5:\n                this._setBackground(this.options.background, newTheme);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function setTheme(_x4) {\n        return _setTheme.apply(this, arguments);\n      }\n\n      return setTheme;\n    }()\n    /**\n     * @returns the current theme applied to the chart or dashboard\n     */\n\n  }, {\n    key: \"getTheme\",\n    value: function () {\n      var _getTheme = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _yield$this$_send5, _yield$this$_send6, result;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._send('get', 'theme');\n\n              case 2:\n                _yield$this$_send5 = _context7.sent;\n                _yield$this$_send6 = _slicedToArray(_yield$this$_send5, 1);\n                result = _yield$this$_send6[0];\n                return _context7.abrupt(\"return\", typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getTheme() {\n        return _getTheme.apply(this, arguments);\n      }\n\n      return getTheme;\n    }()\n  }, {\n    key: \"_configureHost\",\n    value: function _configureHost(hostBuilder) {\n      var _this = this;\n\n      return hostBuilder.on('refreshToken', function () {\n        return _this._retrieveAndSetToken();\n      });\n    }\n  }, {\n    key: \"_configureEmbedRoot\",\n    value: function _configureEmbedRoot(embedRoot) {\n      return embedRoot;\n    }\n  }, {\n    key: \"_setBackground\",\n    value: function _setBackground(background, theme) {\n      this.iframe.style.backgroundColor = getBackground(background, theme, this.COLOUR.LIGHT, this.COLOUR.DARK);\n    }\n  }, {\n    key: \"_retrieveAndSetToken\",\n    value: function () {\n      var _retrieveAndSetToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!this.options.getUserToken) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                _context8.next = 3;\n                return this.options.getUserToken();\n\n              case 3:\n                token = _context8.sent;\n                _context8.next = 6;\n                return this._send('set', 'token', token);\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _retrieveAndSetToken() {\n        return _retrieveAndSetToken2.apply(this, arguments);\n      }\n\n      return _retrieveAndSetToken;\n    }()\n    /**\n     * Send message to embedded app.\n     */\n\n  }, {\n    key: \"_send\",\n    value: function _send(eventName) {\n      if (this.connection) {\n        var _this$connection;\n\n        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          payload[_key - 1] = arguments[_key];\n        }\n\n        return (_this$connection = this.connection).sendAndReceive.apply(_this$connection, [eventName].concat(payload));\n      }\n\n      return Promise.reject(this.ERRORS.SEND);\n    }\n  }]);\n\n  return BaseEmbedItem;\n}();\n\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar eventHandlerIndex = Date.now();\n\nfunction EventSource(Sender) {\n  var _temp;\n\n  return _temp = /*#__PURE__*/function (_Sender) {\n    _inherits(_temp, _Sender);\n\n    var _super = _createSuper(_temp);\n\n    function _temp() {\n      var _this2;\n\n      _classCallCheck(this, _temp);\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this2 = _super.call.apply(_super, [this].concat(args));\n\n      _defineProperty$1(_assertThisInitialized(_this2), \"_eventHandlers\", {\n        click: {} // refresh: {} To be added soon\n\n      });\n\n      return _this2;\n    }\n    /**\n     * Handle the event sent from embedded app.\n     */\n\n\n    _createClass(_temp, [{\n      key: \"_handleEvent\",\n      value: function _handleEvent(event, payload, handlerIds) {\n        var handlers = this._eventHandlers[event];\n\n        var _iterator2 = _createForOfIteratorHelper(handlerIds),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var id = _step2.value;\n\n            try {\n              var _handlers$id; // since communication between host and SDK is async,\n              // it's possible that some handlers have been removed;\n              // thus needs to check if handler still exists before calling\n\n\n              (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n            } catch (error) {\n              console.warn(\"Error calling handler for event [\".concat(event, \"]: \").concat(error));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      /**\n       * Sets an event listener\n       * @param event - the event you are subscribing to\n       * @param eventHandler - the callback to be executed when the event is triggered\n       * @param options - optional options object, can be used to customise when handler is called\n       */\n\n    }, {\n      key: \"addEventListener\",\n      value: function addEventListener(event, eventHandler, options) {\n        var _h$options$includes;\n\n        var handlers = this._eventHandlers[event];\n\n        if (!handlers) {\n          throw new Error(\"Not supported event: \".concat(event));\n        }\n\n        var h = {\n          handle: eventHandler,\n          options: {\n            includes: options === null || options === void 0 ? void 0 : options.includes\n          }\n        };\n\n        if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(function (f) {\n          return _isEmpty(f);\n        })) {\n          // eslint-disable-next-line no-console\n          console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n        } // ignore if same handler and options have been added already\n\n\n        if (!Object.keys(handlers).some(function (id) {\n          return _isEqual(handlers[id], h);\n        })) {\n          var handlerId = (++eventHandlerIndex).toString(36);\n          handlers[handlerId] = h;\n          return this._send('eventHandler', event, {\n            handlerId: handlerId,\n            options: h.options\n          });\n        }\n\n        return Promise.resolve();\n      }\n      /**\n       * Removes an event listener\n       * @param event - the event you are unsubscribing from\n       * @param eventHandler - the event listener function you are unsubscribing from\n       * @param options - optional options object used when addEventListener\n       */\n\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(event, eventHandler, options) {\n        var handlers = this._eventHandlers[event];\n\n        if (!handlers) {\n          throw new Error(\"Not supported event: \".concat(event));\n        }\n\n        var h = {\n          handle: eventHandler,\n          options: {\n            includes: options === null || options === void 0 ? void 0 : options.includes\n          }\n        };\n        var handlerId = Object.keys(handlers).find(function (id) {\n          return _isEqual(handlers[id], h);\n        });\n\n        if (handlerId) {\n          delete handlers[handlerId];\n          return this._send('eventHandler', event, {\n            handlerId: handlerId\n          });\n        }\n\n        return Promise.resolve();\n      }\n    }]);\n\n    return _temp;\n  }(Sender), _temp;\n}\n\nfunction Refreshable(Sender) {\n  return /*#__PURE__*/function (_Sender2) {\n    _inherits(_class, _Sender2);\n\n    var _super2 = _createSuper(_class);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(_class, [{\n      key: \"refresh\",\n      value:\n      /**\n       * Triggers a refresh of the chart or dashboard (if it has been embedded).\n       *\n       * @returns a promise that resolves once the chart or dashboard updated its data\n       */\n      function () {\n        var _refresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n          return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  _context9.next = 2;\n                  return this._send('refresh');\n\n                case 2:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9, this);\n        }));\n\n        function refresh() {\n          return _refresh.apply(this, arguments);\n        }\n\n        return refresh;\n      }()\n    }]);\n\n    return _class;\n  }(Sender);\n}\n\nfunction _defineProperty$2(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar getChartOptions = function getChartOptions(options) {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  var sharedEmbedOptions = getSharedEmbedOptions(options);\n  var chartId = options.chartId,\n      filter = options.filter,\n      refreshInterval = options.refreshInterval; // Verify chart embed options\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  return _objectSpread(_objectSpread({}, sharedEmbedOptions), {}, {\n    chartId: chartId,\n    filter: filter,\n    refreshInterval: refreshInterval\n  });\n};\n\nvar ChartEventSender = /*#__PURE__*/function (_BaseEmbedItem) {\n  _inherits(ChartEventSender, _BaseEmbedItem);\n\n  var _super3 = _createSuper(ChartEventSender);\n\n  /** @ignore */\n  function ChartEventSender(options) {\n    var _this3;\n\n    _classCallCheck(this, ChartEventSender);\n\n    _this3 = _super3.call(this);\n\n    _defineProperty$2(_assertThisInitialized(_this3), \"name\", 'Embedded Chart');\n\n    _defineProperty$2(_assertThisInitialized(_this3), \"ERRORS\", {\n      SEND: 'Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.',\n      IFRAME: 'A chart can only be rendered into a container once'\n    });\n\n    _defineProperty$2(_assertThisInitialized(_this3), \"COLOUR\", {\n      LIGHT: '#FFFFFF',\n      DARK: '#21313C'\n    });\n\n    _defineProperty$2(_assertThisInitialized(_this3), \"options\", void 0);\n\n    _this3.options = getChartOptions(options);\n    return _this3;\n  }\n\n  _createClass(ChartEventSender, [{\n    key: \"getEmbedUrl\",\n    value: function getEmbedUrl() {\n      return getChartUrl(this.options);\n    }\n  }]);\n\n  return ChartEventSender;\n}(BaseEmbedItem);\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\n\nvar Chart = /*#__PURE__*/function (_Refreshable) {\n  _inherits(Chart, _Refreshable);\n\n  var _super4 = _createSuper(Chart);\n\n  function Chart() {\n    _classCallCheck(this, Chart);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(Chart, [{\n    key: \"getRefreshInterval\",\n    value:\n    /**\n     * @returns the number of seconds a chart will wait before refreshing\n     * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n     */\n    function () {\n      var _getRefreshInterval = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var _yield$this$_send7, _yield$this$_send8, result;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this._send('get', 'autorefresh');\n\n              case 2:\n                _yield$this$_send7 = _context10.sent;\n                _yield$this$_send8 = _slicedToArray(_yield$this$_send7, 1);\n                result = _yield$this$_send8[0];\n                console.warn(\"The 'getRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n                return _context10.abrupt(\"return\", typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getRefreshInterval() {\n        return _getRefreshInterval.apply(this, arguments);\n      }\n\n      return getRefreshInterval;\n    }()\n    /**\n     * Set the number of seconds a chart will wait before refreshing.\n     *\n     * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n     * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n     */\n\n  }, {\n    key: \"setRefreshInterval\",\n    value: function () {\n      var _setRefreshInterval = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(value) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(typeof value !== 'number')) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", Promise.reject('refreshInterval property value should be a number'));\n\n              case 2:\n                console.warn(\"The 'setRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n                _context11.next = 5;\n                return this._send('set', 'autorefresh', value);\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function setRefreshInterval(_x5) {\n        return _setRefreshInterval.apply(this, arguments);\n      }\n\n      return setRefreshInterval;\n    }()\n    /**\n     * @returns the current filter applied to the embedded chart.\n     */\n\n  }, {\n    key: \"getFilter\",\n    value: function () {\n      var _getFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _yield$this$_send9, _yield$this$_send10, result;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this._send('get', 'filter');\n\n              case 2:\n                _yield$this$_send9 = _context12.sent;\n                _yield$this$_send10 = _slicedToArray(_yield$this$_send9, 1);\n                result = _yield$this$_send10[0];\n                return _context12.abrupt(\"return\", typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getFilter() {\n        return _getFilter.apply(this, arguments);\n      }\n\n      return getFilter;\n    }()\n    /**\n     * Sets the filter to apply to the embedded chart.\n     *\n     * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n     * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n     */\n\n  }, {\n    key: \"setFilter\",\n    value: function () {\n      var _setFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(value) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!(typeof value !== 'object' || value === null || Array.isArray(value))) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", Promise.reject('filter property value should be an object'));\n\n              case 2:\n                _context13.next = 4;\n                return this._send('set', 'filter', EJSON.stringify(value, {\n                  relaxed: false\n                }));\n\n              case 4:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function setFilter(_x6) {\n        return _setFilter.apply(this, arguments);\n      }\n\n      return setFilter;\n    }()\n    /**\n     * @returns the current highlight applied to the embedded chart.\n     */\n\n  }, {\n    key: \"getHighlight\",\n    value: function () {\n      var _getHighlight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var _yield$this$_send11, _yield$this$_send12, result;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this._send('get', 'highlight');\n\n              case 2:\n                _yield$this$_send11 = _context14.sent;\n                _yield$this$_send12 = _slicedToArray(_yield$this$_send11, 1);\n                result = _yield$this$_send12[0];\n                return _context14.abrupt(\"return\", typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getHighlight() {\n        return _getHighlight.apply(this, arguments);\n      }\n\n      return getHighlight;\n    }()\n    /**\n     * Sets the highlight to apply to the embedded chart.\n     *\n     * This is the exact same object that can be used in 'setFilter'.\n     * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n     * @param value The highlight object to be applied to the chart\n     */\n\n  }, {\n    key: \"setHighlight\",\n    value: function () {\n      var _setHighlight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(value) {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!(typeof value !== 'object' || value === null || Array.isArray(value))) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", Promise.reject('highlight property value should be an object'));\n\n              case 2:\n                _context15.next = 4;\n                return this._send('set', 'highlight', EJSON.stringify(value, {\n                  relaxed: false\n                }));\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function setHighlight(_x7) {\n        return _setHighlight.apply(this, arguments);\n      }\n\n      return setHighlight;\n    }()\n  }, {\n    key: \"_configureHost\",\n    value: function _configureHost(hostBuilder) {\n      return _get(_getPrototypeOf(Chart.prototype), \"_configureHost\", this).call(this, hostBuilder).on('event', this._handleEvent.bind(this));\n    }\n    /**\n     * @returns the data of the embedded chart.\n     */\n\n  }, {\n    key: \"getData\",\n    value: function () {\n      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var _yield$this$_send13, _yield$this$_send14, result;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this._send('get', 'data');\n\n              case 2:\n                _yield$this$_send13 = _context16.sent;\n                _yield$this$_send14 = _slicedToArray(_yield$this$_send13, 1);\n                result = _yield$this$_send14[0];\n                return _context16.abrupt(\"return\", typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function getData() {\n        return _getData.apply(this, arguments);\n      }\n\n      return getData;\n    }()\n  }]);\n\n  return Chart;\n}(Refreshable(EventSource(ChartEventSender)));\n\nvar DashboardChartEventSender = /*#__PURE__*/function () {\n  function DashboardChartEventSender(chartId, dashboard) {\n    _classCallCheck(this, DashboardChartEventSender);\n\n    this.chartId = chartId;\n    this.dashboard = dashboard;\n  }\n  /**\n   * Send message to embedded app via dashboard.\n   */\n\n\n  _createClass(DashboardChartEventSender, [{\n    key: \"_send\",\n    value: function _send(msgName) {\n      var _this$dashboard;\n\n      for (var _len3 = arguments.length, payload = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        payload[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_this$dashboard = this.dashboard)._send.apply(_this$dashboard, [msgName].concat(payload, [this.chartId]));\n    }\n  }]);\n\n  return DashboardChartEventSender;\n}();\n\nvar DashboardChart = /*#__PURE__*/function (_Refreshable2) {\n  _inherits(DashboardChart, _Refreshable2);\n\n  var _super5 = _createSuper(DashboardChart);\n\n  function DashboardChart() {\n    _classCallCheck(this, DashboardChart);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return _createClass(DashboardChart);\n}(Refreshable(EventSource(DashboardChartEventSender)));\n\nfunction _defineProperty$3(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar getDashboardOptions = function getDashboardOptions(options) {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  var sharedEmbedOptions = getSharedEmbedOptions(options);\n  var dashboardId = options.dashboardId,\n      chartsBackground = options.chartsBackground,\n      widthMode = options.widthMode,\n      heightMode = options.heightMode,\n      showTitleAndDesc = options.showTitleAndDesc; // Verify dashboard embed options\n\n  if (typeof dashboardId !== 'string' || dashboardId.length === 0) {\n    throw new Error('dashboardId must be specified');\n  }\n\n  if (chartsBackground !== undefined && typeof chartsBackground !== 'string') {\n    throw new Error('chartsBackground must be a string if specified');\n  }\n\n  if (widthMode !== undefined && typeof widthMode !== 'string') {\n    throw new Error('widthMode must be a string if specified');\n  }\n\n  if (widthMode !== undefined && widthMode !== SCALING_ENUM.FIXED && widthMode !== SCALING_ENUM.SCALE) {\n    throw new Error(\"widthMode must be \\\"\".concat(SCALING_ENUM.FIXED, \"\\\" or \\\"\").concat(SCALING_ENUM.SCALE, \"\\\"\"));\n  }\n\n  if (heightMode !== undefined && typeof heightMode !== 'string') {\n    throw new Error('heightMode must be a string if specified');\n  }\n\n  if (heightMode !== undefined && heightMode !== SCALING_ENUM.FIXED && heightMode !== SCALING_ENUM.SCALE) {\n    throw new Error(\"heightMode must be \\\"\".concat(SCALING_ENUM.FIXED, \"\\\" or \\\"\").concat(SCALING_ENUM.SCALE, \"\\\"\"));\n  }\n\n  if (showTitleAndDesc !== undefined && typeof showTitleAndDesc !== 'boolean') {\n    throw new Error('showTitleAndDesc must be a boolean value if specified');\n  }\n\n  return _objectSpread(_objectSpread({}, sharedEmbedOptions), {}, {\n    dashboardId: dashboardId,\n    chartsBackground: chartsBackground,\n    widthMode: widthMode,\n    heightMode: heightMode,\n    showTitleAndDesc: showTitleAndDesc\n  });\n};\n\nvar DashboardEventSender = /*#__PURE__*/function (_BaseEmbedItem2) {\n  _inherits(DashboardEventSender, _BaseEmbedItem2);\n\n  var _super6 = _createSuper(DashboardEventSender);\n\n  /** @ignore */\n  function DashboardEventSender(options) {\n    var _this4;\n\n    _classCallCheck(this, DashboardEventSender);\n\n    _this4 = _super6.call(this);\n\n    _defineProperty$3(_assertThisInitialized(_this4), \"name\", 'Embedded Dashboard');\n\n    _defineProperty$3(_assertThisInitialized(_this4), \"ERRORS\", {\n      SEND: 'Dashboard has not been rendered. Ensure that you wait for the promise returned by `dashboard.render()` before trying to manipulate a dashboard.',\n      IFRAME: 'A dashboard can only be rendered into a container once'\n    });\n\n    _defineProperty$3(_assertThisInitialized(_this4), \"COLOUR\", {\n      LIGHT: '#F1F5F4',\n      DARK: '#12212C'\n    });\n\n    _defineProperty$3(_assertThisInitialized(_this4), \"options\", void 0);\n\n    _this4.options = getDashboardOptions(options);\n    return _this4;\n  }\n\n  _createClass(DashboardEventSender, [{\n    key: \"getEmbedUrl\",\n    value: function getEmbedUrl() {\n      return getDashboardUrl(this.options);\n    }\n  }]);\n\n  return DashboardEventSender;\n}(BaseEmbedItem);\n/**\n * # Dashboard\n *\n * Allows you to interact and embed dashboards into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const dashboard = sdk.createDashboard({ ... });\n *\n * // renders a dashboard\n * dashboard.render(document.getElementById('embed-dashboard'));\n *\n * ```\n */\n\n\nvar Dashboard = /*#__PURE__*/function (_Refreshable3) {\n  _inherits(Dashboard, _Refreshable3);\n\n  var _super7 = _createSuper(Dashboard);\n\n  function Dashboard() {\n    var _this5;\n\n    _classCallCheck(this, Dashboard);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this5 = _super7.call.apply(_super7, [this].concat(args));\n\n    _defineProperty$3(_assertThisInitialized(_this5), \"charts\", {});\n\n    return _this5;\n  }\n  /**\n   * @returns current chartsBackground or empty string if not set\n   */\n\n\n  _createClass(Dashboard, [{\n    key: \"getChartsBackground\",\n    value: function () {\n      var _getChartsBackground = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var _yield$this$_send15, _yield$this$_send16, result;\n\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this._send('get', 'chartsBackground');\n\n              case 2:\n                _yield$this$_send15 = _context17.sent;\n                _yield$this$_send16 = _slicedToArray(_yield$this$_send15, 1);\n                result = _yield$this$_send16[0];\n                return _context17.abrupt(\"return\", typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getChartsBackground() {\n        return _getChartsBackground.apply(this, arguments);\n      }\n\n      return getChartsBackground;\n    }()\n    /**\n     * Set a custom background color for all charts.\n     * To clear existing value, set it to empty string.\n     */\n\n  }, {\n    key: \"setChartsBackground\",\n    value: function () {\n      var _setChartsBackground = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(value) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(typeof value !== 'string')) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\", Promise.reject('chartsBackground property value should be a string'));\n\n              case 2:\n                _context18.next = 4;\n                return this._send('set', 'chartsBackground', value);\n\n              case 4:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function setChartsBackground(_x8) {\n        return _setChartsBackground.apply(this, arguments);\n      }\n\n      return setChartsBackground;\n    }()\n    /**\n     * @returns whether attribution logo should be shown\n     */\n\n  }, {\n    key: \"isShowAttribution\",\n    value: function () {\n      var _isShowAttribution = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        var _yield$this$_send17, _yield$this$_send18, result;\n\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this._send('get', 'attribution');\n\n              case 2:\n                _yield$this$_send17 = _context19.sent;\n                _yield$this$_send18 = _slicedToArray(_yield$this$_send17, 1);\n                result = _yield$this$_send18[0];\n                return _context19.abrupt(\"return\", typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function isShowAttribution() {\n        return _isShowAttribution.apply(this, arguments);\n      }\n\n      return isShowAttribution;\n    }()\n    /**\n     * Enable/Disable attribution logo.\n     */\n\n  }, {\n    key: \"setShowAttribution\",\n    value: function () {\n      var _setShowAttribution = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(value) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(typeof value !== 'boolean')) {\n                  _context20.next = 2;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\", Promise.reject('showAttribution property value should be a boolean'));\n\n              case 2:\n                _context20.next = 4;\n                return this._send('set', 'attribution', value);\n\n              case 4:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function setShowAttribution(_x9) {\n        return _setShowAttribution.apply(this, arguments);\n      }\n\n      return setShowAttribution;\n    }()\n    /**\n     * @returns get width scaling mode of embedded dashboard\n     */\n\n  }, {\n    key: \"getWidthMode\",\n    value: function () {\n      var _getWidthMode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n        var _yield$this$_send19, _yield$this$_send20, result;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this._send('get', 'scalingWidth');\n\n              case 2:\n                _yield$this$_send19 = _context21.sent;\n                _yield$this$_send20 = _slicedToArray(_yield$this$_send19, 1);\n                result = _yield$this$_send20[0];\n                return _context21.abrupt(\"return\", result === SCALING_ENUM.FIXED || result === SCALING_ENUM.SCALE ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getWidthMode() {\n        return _getWidthMode.apply(this, arguments);\n      }\n\n      return getWidthMode;\n    }()\n    /**\n     * Set width scaling mode for embedded dashboard\n     */\n\n  }, {\n    key: \"setWidthMode\",\n    value: function () {\n      var _setWidthMode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(value) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (['fixed', 'scale'].includes(value)) {\n                  _context22.next = 2;\n                  break;\n                }\n\n                return _context22.abrupt(\"return\", Promise.reject('widthMode property value should be a string value of \"fixed\" or \"scale\"'));\n\n              case 2:\n                _context22.next = 4;\n                return this._send('set', 'scalingWidth', value);\n\n              case 4:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function setWidthMode(_x10) {\n        return _setWidthMode.apply(this, arguments);\n      }\n\n      return setWidthMode;\n    }()\n    /**\n     * @returns get height scaling mode of embedded dashboard\n     */\n\n  }, {\n    key: \"getHeightMode\",\n    value: function () {\n      var _getHeightMode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        var _yield$this$_send21, _yield$this$_send22, result;\n\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this._send('get', 'scalingHeight');\n\n              case 2:\n                _yield$this$_send21 = _context23.sent;\n                _yield$this$_send22 = _slicedToArray(_yield$this$_send21, 1);\n                result = _yield$this$_send22[0];\n                return _context23.abrupt(\"return\", result === 'fixed' || result === 'scale' ? result : Promise.reject('unexpected response received from iframe'));\n\n              case 6:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function getHeightMode() {\n        return _getHeightMode.apply(this, arguments);\n      }\n\n      return getHeightMode;\n    }()\n    /**\n     * Set height scaling mode for embedded dashboard\n     */\n\n  }, {\n    key: \"setHeightMode\",\n    value: function () {\n      var _setHeightMode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(value) {\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (['fixed', 'scale'].includes(value)) {\n                  _context24.next = 2;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", Promise.reject('heightMode property value should be a string value of \"fixed\" or \"scale\"'));\n\n              case 2:\n                _context24.next = 4;\n                return this._send('set', 'scalingHeight', value);\n\n              case 4:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function setHeightMode(_x11) {\n        return _setHeightMode.apply(this, arguments);\n      }\n\n      return setHeightMode;\n    }()\n    /**\n     * @returns get the dashboard chart with specified id\n     */\n\n  }, {\n    key: \"getChart\",\n    value: function () {\n      var _getChart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(id) {\n        var _yield$this$_send23, _yield$this$_send24, chartIds;\n\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (this.charts[id]) {\n                  _context25.next = 11;\n                  break;\n                }\n\n                _context25.next = 3;\n                return this._send('get', 'charts', [id]);\n\n              case 3:\n                _yield$this$_send23 = _context25.sent;\n                _yield$this$_send24 = _slicedToArray(_yield$this$_send23, 1);\n                chartIds = _yield$this$_send24[0];\n\n                if (Array.isArray(chartIds)) {\n                  _context25.next = 8;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", Promise.reject('unexpected response received from iframe'));\n\n              case 8:\n                if (!(chartIds.length !== 1)) {\n                  _context25.next = 10;\n                  break;\n                }\n\n                return _context25.abrupt(\"return\", Promise.reject('Invalid chart id: ' + id));\n\n              case 10:\n                this.charts[id] = new DashboardChart(id, this);\n\n              case 11:\n                return _context25.abrupt(\"return\", this.charts[id]);\n\n              case 12:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function getChart(_x12) {\n        return _getChart.apply(this, arguments);\n      }\n\n      return getChart;\n    }()\n    /**\n     * @returns all charts on the dashboard\n     */\n\n  }, {\n    key: \"getAllCharts\",\n    value: function () {\n      var _getAllCharts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n        var _this6 = this;\n\n        var _yield$this$_send25, _yield$this$_send26, chartIds, charts;\n\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this._send('get', 'charts');\n\n              case 2:\n                _yield$this$_send25 = _context26.sent;\n                _yield$this$_send26 = _slicedToArray(_yield$this$_send25, 1);\n                chartIds = _yield$this$_send26[0];\n\n                if (Array.isArray(chartIds)) {\n                  _context26.next = 7;\n                  break;\n                }\n\n                return _context26.abrupt(\"return\", Promise.reject('unexpected response received from iframe'));\n\n              case 7:\n                charts = [];\n                chartIds.forEach(function (id) {\n                  if (!_this6.charts[id]) {\n                    _this6.charts[id] = new DashboardChart(id, _this6);\n                  }\n\n                  charts.push(_this6.charts[id]);\n                });\n                return _context26.abrupt(\"return\", charts);\n\n              case 10:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function getAllCharts() {\n        return _getAllCharts.apply(this, arguments);\n      }\n\n      return getAllCharts;\n    }()\n  }, {\n    key: \"_configureHost\",\n    value: function _configureHost(hostBuilder) {\n      var _this7 = this;\n\n      return _get(_getPrototypeOf(Dashboard.prototype), \"_configureHost\", this).call(this, hostBuilder).on('event', function (event, payload, handlerIds) {\n        var chartId = payload.chartId;\n\n        _this7.charts[chartId]._handleEvent(event, payload, handlerIds);\n      });\n    }\n  }]);\n\n  return Dashboard;\n}(Refreshable(DashboardEventSender)); // Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\n\n\nvar isJWTExpired = function isJWTExpired(jwt) {\n  try {\n    var _jwt$split = jwt.split('.'),\n        _jwt$split2 = _slicedToArray(_jwt$split, 3),\n        header = _jwt$split2[0],\n        payload = _jwt$split2[1],\n        signature = _jwt$split2[2];\n\n    var _JSON$parse = JSON.parse(atob(payload)),\n        exp = _JSON$parse.exp; // Check the current time against the expiry (minus 5 minutes) in the token\n\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nfunction getRealmUserToken(_x13) {\n  return _getRealmUserToken.apply(this, arguments);\n}\n\nfunction _getRealmUserToken() {\n  _getRealmUserToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(stitchAppClient) {\n    var client;\n    return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n      while (1) {\n        switch (_context27.prev = _context27.next) {\n          case 0:\n            client = stitchAppClient;\n\n            if (!(!client.auth || !client.auth.authInfo)) {\n              _context27.next = 3;\n              break;\n            }\n\n            throw new Error('Unfamiliar Stitch client version');\n\n          case 3:\n            if (client.auth.isLoggedIn) {\n              _context27.next = 5;\n              break;\n            }\n\n            throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n\n          case 5:\n            if (client.auth.authInfo.accessToken) {\n              _context27.next = 7;\n              break;\n            }\n\n            throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n\n          case 7:\n            if (!isJWTExpired(client.auth.authInfo.accessToken)) {\n              _context27.next = 19;\n              break;\n            }\n\n            if (!client.auth.refreshCustomData) {\n              _context27.next = 13;\n              break;\n            }\n\n            _context27.next = 11;\n            return client.auth.refreshCustomData();\n\n          case 11:\n            _context27.next = 19;\n            break;\n\n          case 13:\n            if (!client.auth.refreshAccessToken) {\n              _context27.next = 18;\n              break;\n            }\n\n            _context27.next = 16;\n            return client.auth.refreshAccessToken();\n\n          case 16:\n            _context27.next = 19;\n            break;\n\n          case 18:\n            throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n\n          case 19:\n            return _context27.abrupt(\"return\", client.auth.authInfo.accessToken);\n\n          case 20:\n          case \"end\":\n            return _context27.stop();\n        }\n      }\n    }, _callee27);\n  }));\n  return _getRealmUserToken.apply(this, arguments);\n}\n\nfunction _defineProperty$4(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Creates an instance of the embedding SDK\n */\n\n\nvar EmbedSDK = /*#__PURE__*/function () {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  function EmbedSDK(options) {\n    _classCallCheck(this, EmbedSDK);\n\n    _defineProperty$4(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  _createClass(EmbedSDK, [{\n    key: \"createChart\",\n    value: function createChart(options) {\n      return new Chart(_objectSpread(_objectSpread({}, this.defaultOptions), options));\n    }\n    /**\n     * Creates a new {@link Dashboard} instance that allows you\n     * to embed a dashboard into your application\n     */\n\n  }, {\n    key: \"createDashboard\",\n    value: function createDashboard(options) {\n      return new Dashboard(_objectSpread(_objectSpread({}, this.defaultOptions), options));\n    }\n  }]);\n\n  return EmbedSDK;\n}();\n\nexport default EmbedSDK;\nexport { getRealmUserToken };","map":{"version":3,"sources":["D:/diom working project/staging/node_modules/@mongodb-js/charts-embed-dom/dist/charts-embed-dom.esm.js"],"names":["EJSON","Chatty","_isEqual","_isEmpty","createElement","name","props","children","element","document","Object","entries","value","assign","style","setAttribute","Array","isArray","child","append","THEME_ENUM","SCALING_ENUM","getSharedEmbedOptions","options","background","baseUrl","autoRefresh","maxDataAge","width","height","theme","showAttribution","getUserToken","length","Error","undefined","includes","getPathname","url","pathname","slice","join","getChartUrl","URL","search","chartId","refreshInterval","filter","encodeURIComponent","stringify","relaxed","toString","e","getDashboardUrl","dashboardId","showTitleAndDesc","widthMode","heightMode","chartsBackground","parseCSSMeasurement","getBackground","lightBackground","darkBackground","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","BaseEmbedItem","container","iframe","ERRORS","IFRAME","embedRoot","_configureEmbedRoot","position","overflow","minHeight","Boolean","host","_configureHost","createHost","getEmbedUrl","withSandboxAttribute","appendTo","build","top","left","border","firstChild","removeChild","appendChild","connect","connection","_setBackground","_retrieveAndSetToken","_send","result","Promise","reject","newTheme","values","LIGHT","hostBuilder","on","backgroundColor","COLOUR","DARK","token","eventName","payload","sendAndReceive","SEND","_defineProperty$1","eventHandlerIndex","Date","now","EventSource","Sender","_temp","args","click","event","handlerIds","handlers","_eventHandlers","id","_handlers$id","handle","error","console","warn","eventHandler","_h$options$includes","h","every","f","keys","some","handlerId","resolve","find","Refreshable","_defineProperty$2","getChartOptions","sharedEmbedOptions","ChartEventSender","Chart","_handleEvent","bind","DashboardChartEventSender","dashboard","msgName","DashboardChart","_defineProperty$3","getDashboardOptions","FIXED","SCALE","DashboardEventSender","Dashboard","charts","chartIds","forEach","push","isJWTExpired","jwt","split","header","signature","JSON","parse","atob","exp","getRealmUserToken","stitchAppClient","client","auth","authInfo","isLoggedIn","accessToken","refreshCustomData","refreshAccessToken","_defineProperty$4","EmbedSDK","defaultOptions"],"mappings":";;;;;;;;;;;;AAAA,SAASA,KAAT,QAAsB,MAAtB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,OAAOC,QAAP,MAAqB,gBAArB;AACA,OAAOC,QAAP,MAAqB,gBAArB,C,CAEA;AACA;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAAwD;AAAA,MAA3BC,KAA2B,uEAAnB,EAAmB;AAAA,MAAfC,QAAe,uEAAJ,EAAI;AACtD,MAAMC,OAAO,GAAGC,QAAQ,CAACL,aAAT,CAAuBC,IAAvB,CAAhB;;AAEA,qCAA4BK,MAAM,CAACC,OAAP,CAAeL,KAAf,CAA5B,qCAAmD;AAA9C;AAAA,QAAOD,KAAP;AAAA,QAAaO,KAAb;;AACH,QAAIP,KAAI,KAAK,OAAb,EAAsB;AACpBK,MAAAA,MAAM,CAACG,MAAP,CAAcL,OAAO,CAACM,KAAtB,EAA6BR,KAAK,CAACQ,KAAnC;AACD,KAFD,MAEO;AACLN,MAAAA,OAAO,CAACO,YAAR,CAAqBV,KAArB,EAA2BO,KAA3B;AACD;AACF;;AATqD,6CAWlCI,KAAK,CAACC,OAAN,CAAcV,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAXH;AAAA;;AAAA;AAWtD,wDAAqE;AAAA,UAA1DW,KAA0D;AACnEV,MAAAA,OAAO,CAACW,MAAR,CAAeD,KAAf;AACD;AAbqD;AAAA;AAAA;AAAA;AAAA;;AAetD,SAAOV,OAAP;AACD;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,IAAIY,UAAJ;;AAEA,CAAC,UAAUA,UAAV,EAAsB;AACrBA,EAAAA,UAAU,CAAC,MAAD,CAAV,GAAqB,MAArB;AACAA,EAAAA,UAAU,CAAC,OAAD,CAAV,GAAsB,OAAtB;AACD,CAHD,EAGGA,UAAU,KAAKA,UAAU,GAAG,EAAlB,CAHb;;AAKA,IAAIC,YAAJ;;AAEA,CAAC,UAAUA,YAAV,EAAwB;AACvBA,EAAAA,YAAY,CAAC,OAAD,CAAZ,GAAwB,OAAxB;AACAA,EAAAA,YAAY,CAAC,OAAD,CAAZ,GAAwB,OAAxB;AACD,CAHD,EAGGA,YAAY,KAAKA,YAAY,GAAG,EAApB,CAHf;AAKA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAAC,OAAO,EAAI;AACvC,MACEC,UADF,GAUID,OAVJ,CACEC,UADF;AAAA,MAEEC,OAFF,GAUIF,OAVJ,CAEEE,OAFF;AAAA,MAGEC,WAHF,GAUIH,OAVJ,CAGEG,WAHF;AAAA,MAIEC,UAJF,GAUIJ,OAVJ,CAIEI,UAJF;AAAA,MAKEC,KALF,GAUIL,OAVJ,CAKEK,KALF;AAAA,MAMEC,MANF,GAUIN,OAVJ,CAMEM,MANF;AAAA,MAOEC,KAPF,GAUIP,OAVJ,CAOEO,KAPF;AAAA,MAQEC,eARF,GAUIR,OAVJ,CAQEQ,eARF;AAAA,MASEC,YATF,GAUIT,OAVJ,CASES,YATF;;AAYA,MAAI,OAAOP,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACQ,MAAR,KAAmB,CAAtD,EAAyD;AACvD,UAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,MAAIV,UAAU,KAAKW,SAAf,IAA4B,OAAOX,UAAP,KAAsB,QAAtD,EAAgE;AAC9D,UAAM,IAAIU,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,MAAIR,WAAW,KAAKS,SAAhB,IAA6B,OAAOT,WAAP,KAAuB,SAAxD,EAAmE;AACjE,UAAM,IAAIQ,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAED,MAAIP,UAAU,KAAKQ,SAAf,IAA4B,OAAOR,UAAP,KAAsB,QAAtD,EAAgE;AAC9D,UAAM,IAAIO,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,MAAIN,KAAK,KAAKO,SAAV,IAAuB,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqBC,QAArB,CAA8B,OAAOR,KAArC,CAA5B,EAAyE;AACvE,UAAM,IAAIM,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAED,MAAIL,MAAM,KAAKM,SAAX,IAAwB,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqBC,QAArB,CAA8B,OAAOP,MAArC,CAA7B,EAA2E;AACzE,UAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,MAAIJ,KAAK,KAAKK,SAAV,IAAuB,OAAOL,KAAP,KAAiB,QAA5C,EAAsD;AACpD,UAAM,IAAII,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAED,MAAIH,eAAe,KAAKI,SAApB,IAAiC,OAAOJ,eAAP,KAA2B,SAAhE,EAA2E;AACzE,UAAM,IAAIG,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,MAAIF,YAAY,KAAKG,SAAjB,IAA8B,OAAOH,YAAP,KAAwB,UAA1D,EAAsE;AACpE,UAAM,IAAIE,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,SAAO;AACLV,IAAAA,UAAU,EAAVA,UADK;AAELC,IAAAA,OAAO,EAAPA,OAFK;AAGLC,IAAAA,WAAW,EAAXA,WAHK;AAILC,IAAAA,UAAU,EAAVA,UAJK;AAKLC,IAAAA,KAAK,EAALA,KALK;AAMLC,IAAAA,MAAM,EAANA,MANK;AAOLC,IAAAA,KAAK,EAALA,KAPK;AAQLC,IAAAA,eAAe,EAAfA,eARK;AASLC,IAAAA,YAAY,EAAZA;AATK,GAAP;AAWD,CA5DD;;AA6DA,IAAMK,WAAW,GAAG,SAAdA,WAAc,CAACC,GAAD,EAAMC,QAAN,EAAmB;AACrC,SAAO,CAACD,GAAG,CAACC,QAAL,EAAeD,GAAG,CAACC,QAAJ,CAAaC,KAAb,CAAmB,CAAC,CAApB,MAA2B,GAA3B,GAAiC,EAAjC,GAAsC,GAArD,EAA0D;AACjED,EAAAA,QADO,EACGE,IADH,CACQ,EADR,CAAP;AAED,CAHD;AAIA;AACA;AACA;;;AAEA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAnB,OAAO,EAAI;AAC7B,MAAI;AACF,QAAMe,GAAG,GAAG,IAAIK,GAAJ,CAAQpB,OAAO,CAACE,OAAhB,CAAZ;AACAa,IAAAA,GAAG,CAACC,QAAJ,GAAeF,WAAW,CAACC,GAAD,EAAM,cAAN,CAA1B;AACAA,IAAAA,GAAG,CAACM,MAAJ,gBAAmBrB,OAAO,CAACsB,OAA3B;;AAEA,QAAItB,OAAO,CAACG,WAAR,KAAwB,KAA5B,EAAmC;AACjCY,MAAAA,GAAG,CAACM,MAAJ;AACD,KAFD,MAEO,IAAIrB,OAAO,CAACG,WAAR,KAAwBS,SAA5B,EAAuC;AAC5CG,MAAAA,GAAG,CAACM,MAAJ,IAAcrB,OAAO,CAACuB,eAAR,0BAA0CvB,OAAO,CAACuB,eAAlD,IAAsE,EAApF;AACD;;AAED,QAAIvB,OAAO,CAACI,UAAR,KAAuBQ,SAA3B,EAAsC;AACpCG,MAAAA,GAAG,CAACM,MAAJ,0BAA6BrB,OAAO,CAACI,UAArC;AACD;;AAED,QAAIJ,OAAO,CAACwB,MAAZ,EAAoB;AAClBT,MAAAA,GAAG,CAACM,MAAJ,sBAAyBI,kBAAkB,CAAChD,KAAK,CAACiD,SAAN,CAAgB1B,OAAO,CAACwB,MAAxB,EAAgC;AAC1EG,QAAAA,OAAO,EAAE;AADiE,OAAhC,CAAD,CAA3C;AAGD;;AAED,QAAI3B,OAAO,CAACO,KAAZ,EAAmB;AACjBQ,MAAAA,GAAG,CAACM,MAAJ,qBAAwBrB,OAAO,CAACO,KAAhC;AACD;;AAED,QAAIP,OAAO,CAACQ,eAAR,KAA4B,KAAhC,EAAuC;AACrCO,MAAAA,GAAG,CAACM,MAAJ;AACD;;AAED,WAAON,GAAG,CAACa,QAAJ,EAAP;AACD,GA9BD,CA8BE,OAAOC,CAAP,EAAU;AACV,UAAM,IAAIlB,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF,CAlCD;AAmCA;AACA;AACA;;;AAEA,IAAMmB,eAAe,GAAG,SAAlBA,eAAkB,CAAA9B,OAAO,EAAI;AACjC,MAAI;AACF,QAAMe,GAAG,GAAG,IAAIK,GAAJ,CAAQpB,OAAO,CAACE,OAAhB,CAAZ;AACAa,IAAAA,GAAG,CAACC,QAAJ,GAAeF,WAAW,CAACC,GAAD,EAAM,kBAAN,CAA1B;AACAA,IAAAA,GAAG,CAACM,MAAJ,gBAAmBrB,OAAO,CAAC+B,WAA3B;;AAEA,QAAI/B,OAAO,CAACG,WAAR,KAAwB,KAA5B,EAAmC;AACjCY,MAAAA,GAAG,CAACM,MAAJ;AACD;;AAED,QAAIrB,OAAO,CAACI,UAAR,KAAuBQ,SAA3B,EAAsC;AACpCG,MAAAA,GAAG,CAACM,MAAJ,0BAA6BrB,OAAO,CAACI,UAArC;AACD;;AAED,QAAIJ,OAAO,CAACgC,gBAAR,KAA6B,IAAjC,EAAuC;AACrCjB,MAAAA,GAAG,CAACM,MAAJ;AACD;;AAED,QAAIrB,OAAO,CAACiC,SAAZ,EAAuB;AACrBlB,MAAAA,GAAG,CAACM,MAAJ,4BAA+BrB,OAAO,CAACiC,SAAvC;AACD;;AAED,QAAIjC,OAAO,CAACkC,UAAZ,EAAwB;AACtBnB,MAAAA,GAAG,CAACM,MAAJ,6BAAgCrB,OAAO,CAACkC,UAAxC;AACD;;AAED,QAAIlC,OAAO,CAACO,KAAZ,EAAmB;AACjBQ,MAAAA,GAAG,CAACM,MAAJ,qBAAwBrB,OAAO,CAACO,KAAhC;AACD;;AAED,QAAIP,OAAO,CAACmC,gBAAZ,EAA8B;AAC5BpB,MAAAA,GAAG,CAACM,MAAJ,gCAAmCrB,OAAO,CAACmC,gBAA3C;AACD;;AAED,QAAInC,OAAO,CAACQ,eAAR,KAA4B,KAAhC,EAAuC;AACrCO,MAAAA,GAAG,CAACM,MAAJ;AACD;;AAED,WAAON,GAAG,CAACa,QAAJ,EAAP;AACD,GAtCD,CAsCE,OAAOC,CAAP,EAAU;AACV,UAAM,IAAIlB,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF,CA1CD;AA2CA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMyB,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAA/C,KAAK,EAAI;AACnC,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,OAAOA,KAAP;AAC/B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,iBAAUA,KAAV;AAC/B,SAAO,IAAP;AACD,CAJD;AAKA;AACA;AACA;AACA;;;AAEA,IAAMgD,aAAa,GAAG,SAAhBA,aAAgB,CAACpC,UAAD,EAAaM,KAAb,EAAoB+B,eAApB,EAAqCC,cAArC,EAAwD;AAC5E,MAAI,OAAOtC,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,CAACS,MAAX,GAAoB,CAA1D,EAA6D,OAAOT,UAAP;AAC7D,MAAIM,KAAK,KAAK,MAAd,EAAsB,OAAOgC,cAAP;AACtB,SAAOD,eAAP;AACD,CAJD;;AAMA,SAASE,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCrD,KAAnC,EAA0C;AAAE,MAAIqD,GAAG,IAAID,GAAX,EAAgB;AAAEtD,IAAAA,MAAM,CAACwD,cAAP,CAAsBF,GAAtB,EAA2BC,GAA3B,EAAgC;AAAErD,MAAAA,KAAK,EAAEA,KAAT;AAAgBuD,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWrD,KAAX;AAAmB;;AAAC,SAAOoD,GAAP;AAAa;;IAE3MM,a;AACJ,2BAAc;AAAA;;AACZP,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,KAAK,CAA1B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,KAAK,CAApB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,SAAP,EAAkB,KAAK,CAAvB,CAAf;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;6EACE,iBAAaQ,SAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACM,KAAKC,MADX;AAAA;AAAA;AAAA;;AAAA,sBAEU,IAAItC,KAAJ,CAAU,KAAKuC,MAAL,CAAYC,MAAtB,CAFV;;AAAA;AAGI;AAGIC,gBAAAA,SANR,GAMoB,KAAKC,mBAAL,CAAyBxE,aAAa,CAAC,KAAD,EAAQ;AAC9DU,kBAAAA,KAAK,EAAE;AACL+D,oBAAAA,QAAQ,EAAE,UADL;AAELC,oBAAAA,QAAQ,EAAE,QAFL;AAGLC,oBAAAA,SAAS,EAAEC,OAAO,CAAC,KAAKzD,OAAL,CAAaM,MAAd,CAAP,GAA+B,CAA/B,GAAmC,MAHzC;AAILD,oBAAAA,KAAK,EAAE+B,mBAAmB,CAAC,KAAKpC,OAAL,CAAaK,KAAd,CAAnB,IAA2C,MAJ7C;AAKLC,oBAAAA,MAAM,EAAE8B,mBAAmB,CAAC,KAAKpC,OAAL,CAAaM,MAAd,CAAnB,IAA4C;AAL/C;AADuD,iBAAR,CAAtC,CANpB,EAcO;;AAGCoD,gBAAAA,IAjBR,GAiBe,KAAKC,cAAL,CAAoBjF,MAAM,CAACkF,UAAP,CAAkB,KAAKC,WAAL,EAAlB,EAAsCC,oBAAtC,CAA2D,eAA3D,EAA4EA,oBAA5E,CAAiG,mBAAjG,EAAsHA,oBAAtH,CAA2I,cAA3I,EAA2JA,oBAA3J,CAAgL,gCAAhL,EAAkNC,QAAlN,CAA2NX,SAA3N,CAApB,EAA2PY,KAA3P,EAjBf,EAiBmR;;AAGjRN,gBAAAA,IAAI,CAACT,MAAL,CAAYzD,YAAZ,CAAyB,YAAzB,EAAuC,KAAKV,IAA5C;AACAK,gBAAAA,MAAM,CAACG,MAAP,CAAcoE,IAAI,CAACT,MAAL,CAAY1D,KAA1B,EAAiC;AAC/B+D,kBAAAA,QAAQ,EAAE,UADqB;AAE/BW,kBAAAA,GAAG,EAAE,CAF0B;AAG/BC,kBAAAA,IAAI,EAAE,CAHyB;AAI/BC,kBAAAA,MAAM,EAAE,CAJuB;AAK/B9D,kBAAAA,KAAK,EAAE,MALwB;AAM/BC,kBAAAA,MAAM,EAAE;AANuB,iBAAjC,EArBF,CA4BM;;AAEJ,uBAAO0C,SAAS,CAACoB,UAAjB;AAA6BpB,kBAAAA,SAAS,CAACqB,WAAV,CAAsBrB,SAAS,CAACoB,UAAhC;AAA7B;;AAEApB,gBAAAA,SAAS,CAACsB,WAAV,CAAsBlB,SAAtB,EAhCF,CAgCoC;;AAhCpC;AAAA,uBAkC0BM,IAAI,CAACa,OAAL,EAlC1B;;AAAA;AAkCE,qBAAKC,UAlCP;AAmCE,qBAAKvB,MAAL,GAAcS,IAAI,CAACT,MAAnB;;AAEA,qBAAKwB,cAAL,CAAoB,KAAKzE,OAAL,CAAaC,UAAjC,EAA6C,KAAKD,OAAL,CAAaO,KAA1D,EArCF,CAqCoE;;;AArCpE;AAAA,uBAwCQ,KAAKmE,oBAAL,EAxCR;;AAAA;AAAA;AAAA,uBA0CQ,KAAKC,KAAL,CAAW,OAAX,CA1CR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AA4CA;AACF;AACA;;;;;oFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKA,KAAL,CAAW,KAAX,EAAkB,aAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,kDAGS,OAAOA,MAAP,KAAkB,QAAlB,IAA8B,OAAOA,MAAP,KAAkB,SAAhD,GAA4DnB,OAAO,CAACmB,MAAD,CAAnE,GAA8EC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAHvF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAKA;AACF;AACA;;;;;qFAGE,kBAAqBzF,KAArB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,SADvB;AAAA;AAAA;AAAA;;AAAA,kDAEWwF,OAAO,CAACC,MAAR,CAAe,gDAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,aAAlB,EAAiCtF,KAAjC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;;;;;oFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKsF,KAAL,CAAW,KAAX,EAAkB,YAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,kDAES,OAAOA,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAF/C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;;;;;oFAGE,kBAAoBzF,KAApB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QADvB;AAAA;AAAA;AAAA;;AAAA,kDAEWwF,OAAO,CAACC,MAAR,CAAe,8CAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,YAAlB,EAAgCtF,KAAhC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;AACA;AACA;;;;;+EAGE,kBAAeA,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QADvB;AAAA;AAAA;AAAA;;AAAA,kDAEWwF,OAAO,CAACC,MAAR,CAAe,yCAAf,CAFX;;AAAA;AAGI;AAGIC,gBAAAA,QANR,GAMmB5F,MAAM,CAAC6F,MAAP,CAAcnF,UAAd,EAA0BgB,QAA1B,CAAmCxB,KAAnC,IAA4CA,KAA5C,GAAoDQ,UAAU,CAACoF,KANlF;AAAA;AAAA,uBAOQ,KAAKN,KAAL,CAAW,KAAX,EAAkB,OAAlB,EAA2BI,QAA3B,CAPR;;AAAA;AASE,qBAAKN,cAAL,CAAoB,KAAKzE,OAAL,CAAaC,UAAjC,EAA6C8E,QAA7C;;AATF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAWA;AACF;AACA;;;;;+EAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKJ,KAAL,CAAW,KAAX,EAAkB,OAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,kDAES,OAAOA,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAF/C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAKA,wBAAeI,WAAf,EAA4B;AAAA;;AAC1B,aAAOA,WAAW,CAACC,EAAZ,CAAe,cAAf,EAA+B;AAAA,eAAM,KAAI,CAACT,oBAAL,EAAN;AAAA,OAA/B,CAAP;AACD;;;WAED,6BAAoBtB,SAApB,EAA+B;AAC7B,aAAOA,SAAP;AACD;;;WAED,wBAAenD,UAAf,EAA2BM,KAA3B,EAAkC;AAChC,WAAK0C,MAAL,CAAY1D,KAAZ,CAAkB6F,eAAlB,GAAoC/C,aAAa,CAACpC,UAAD,EAAaM,KAAb,EAAoB,KAAK8E,MAAL,CAAYJ,KAAhC,EAAuC,KAAKI,MAAL,CAAYC,IAAnD,CAAjD;AACD;;;;2FAED;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACM,KAAKtF,OAAL,CAAaS,YADnB;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAEwB,KAAKT,OAAL,CAAaS,YAAb,EAFxB;;AAAA;AAEU8E,gBAAAA,KAFV;AAAA;AAAA,uBAGU,KAAKZ,KAAL,CAAW,KAAX,EAAkB,OAAlB,EAA2BY,KAA3B,CAHV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAMA;AACF;AACA;;;;WAGE,eAAMC,SAAN,EAA6B;AAC3B,UAAI,KAAKhB,UAAT,EAAqB;AAAA;;AAAA,0CADHiB,OACG;AADHA,UAAAA,OACG;AAAA;;AACnB,eAAO,yBAAKjB,UAAL,EAAgBkB,cAAhB,0BAA+BF,SAA/B,SAA6CC,OAA7C,EAAP;AACD;;AAED,aAAOZ,OAAO,CAACC,MAAR,CAAe,KAAK5B,MAAL,CAAYyC,IAA3B,CAAP;AACD;;;;;;AAIH,SAASC,iBAAT,CAA2BnD,GAA3B,EAAgCC,GAAhC,EAAqCrD,KAArC,EAA4C;AAAE,MAAIqD,GAAG,IAAID,GAAX,EAAgB;AAAEtD,IAAAA,MAAM,CAACwD,cAAP,CAAsBF,GAAtB,EAA2BC,GAA3B,EAAgC;AAAErD,MAAAA,KAAK,EAAEA,KAAT;AAAgBuD,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWrD,KAAX;AAAmB;;AAAC,SAAOoD,GAAP;AAAa;;AAEnN,IAAIoD,iBAAiB,GAAGC,IAAI,CAACC,GAAL,EAAxB;;AACA,SAASC,WAAT,CAAqBC,MAArB,EAA6B;AAC3B,MAAIC,KAAJ;;AAEA,SAAOA,KAAK;AAAA;;AAAA;;AACV,qBAAqB;AAAA;;AAAA;;AAAA,yCAANC,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACnB,uDAASA,IAAT;;AAEAP,MAAAA,iBAAiB,iCAAO,gBAAP,EAAyB;AACxCQ,QAAAA,KAAK,EAAE,EADiC,CAC9B;;AAD8B,OAAzB,CAAjB;;AAHmB;AAOpB;AAED;AACJ;AACA;;;AAZc;AAAA;AAAA,aAaV,sBAAaC,KAAb,EAAoBZ,OAApB,EAA6Ba,UAA7B,EAAyC;AACvC,YAAMC,QAAQ,GAAG,KAAKC,cAAL,CAAoBH,KAApB,CAAjB;;AADuC,oDAGtBC,UAHsB;AAAA;;AAAA;AAGvC,iEAA6B;AAAA,gBAAlBG,EAAkB;;AAC3B,gBAAI;AACF,kBAAIC,YAAJ,CADE,CAGF;AACA;AACA;;;AACA,eAACA,YAAY,GAAGH,QAAQ,CAACE,EAAD,CAAxB,MAAkC,IAAlC,IAA0CC,YAAY,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,YAAY,CAACC,MAAb,CAAoBlB,OAApB,CAA7E;AACD,aAPD,CAOE,OAAOmB,KAAP,EAAc;AACdC,cAAAA,OAAO,CAACC,IAAR,4CAAiDT,KAAjD,gBAA4DO,KAA5D;AACD;AACF;AAdsC;AAAA;AAAA;AAAA;AAAA;AAexC;AACD;AACJ;AACA;AACA;AACA;AACA;;AAlCc;AAAA;AAAA,aAqCV,0BAAiBP,KAAjB,EAAwBU,YAAxB,EAAsC/G,OAAtC,EAA+C;AAC7C,YAAIgH,mBAAJ;;AAEA,YAAMT,QAAQ,GAAG,KAAKC,cAAL,CAAoBH,KAApB,CAAjB;;AAEA,YAAI,CAACE,QAAL,EAAe;AACb,gBAAM,IAAI5F,KAAJ,gCAAkC0F,KAAlC,EAAN;AACD;;AAED,YAAMY,CAAC,GAAG;AACRN,UAAAA,MAAM,EAAEI,YADA;AAER/G,UAAAA,OAAO,EAAE;AACPa,YAAAA,QAAQ,EAAEb,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACa;AAD7D;AAFD,SAAV;;AAOA,YAAI,CAACmG,mBAAmB,GAAGC,CAAC,CAACjH,OAAF,CAAUa,QAAjC,MAA+C,IAA/C,IAAuDmG,mBAAmB,KAAK,KAAK,CAApF,IAAyFA,mBAAmB,CAACE,KAApB,CAA0B,UAAAC,CAAC;AAAA,iBAAIvI,QAAQ,CAACuI,CAAD,CAAZ;AAAA,SAA3B,CAA7F,EAA0I;AACxI;AACAN,UAAAA,OAAO,CAACC,IAAR,CAAa,8FAAb;AACD,SAnB4C,CAmB3C;;;AAGF,YAAI,CAAC3H,MAAM,CAACiI,IAAP,CAAYb,QAAZ,EAAsBc,IAAtB,CAA2B,UAAAZ,EAAE;AAAA,iBAAI9H,QAAQ,CAAC4H,QAAQ,CAACE,EAAD,CAAT,EAAeQ,CAAf,CAAZ;AAAA,SAA7B,CAAL,EAAkE;AAChE,cAAMK,SAAS,GAAG,CAAC,EAAEzB,iBAAH,EAAsBjE,QAAtB,CAA+B,EAA/B,CAAlB;AACA2E,UAAAA,QAAQ,CAACe,SAAD,CAAR,GAAsBL,CAAtB;AACA,iBAAO,KAAKtC,KAAL,CAAW,cAAX,EAA2B0B,KAA3B,EAAkC;AACvCiB,YAAAA,SAAS,EAATA,SADuC;AAEvCtH,YAAAA,OAAO,EAAEiH,CAAC,CAACjH;AAF4B,WAAlC,CAAP;AAID;;AAED,eAAO6E,OAAO,CAAC0C,OAAR,EAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;;AA3Ec;AAAA;AAAA,aA8EV,6BAAoBlB,KAApB,EAA2BU,YAA3B,EAAyC/G,OAAzC,EAAkD;AAChD,YAAMuG,QAAQ,GAAG,KAAKC,cAAL,CAAoBH,KAApB,CAAjB;;AAEA,YAAI,CAACE,QAAL,EAAe;AACb,gBAAM,IAAI5F,KAAJ,gCAAkC0F,KAAlC,EAAN;AACD;;AAED,YAAMY,CAAC,GAAG;AACRN,UAAAA,MAAM,EAAEI,YADA;AAER/G,UAAAA,OAAO,EAAE;AACPa,YAAAA,QAAQ,EAAEb,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACa;AAD7D;AAFD,SAAV;AAMA,YAAMyG,SAAS,GAAGnI,MAAM,CAACiI,IAAP,CAAYb,QAAZ,EAAsBiB,IAAtB,CAA2B,UAAAf,EAAE;AAAA,iBAAI9H,QAAQ,CAAC4H,QAAQ,CAACE,EAAD,CAAT,EAAeQ,CAAf,CAAZ;AAAA,SAA7B,CAAlB;;AAEA,YAAIK,SAAJ,EAAe;AACb,iBAAOf,QAAQ,CAACe,SAAD,CAAf;AACA,iBAAO,KAAK3C,KAAL,CAAW,cAAX,EAA2B0B,KAA3B,EAAkC;AACvCiB,YAAAA,SAAS,EAATA;AADuC,WAAlC,CAAP;AAGD;;AAED,eAAOzC,OAAO,CAAC0C,OAAR,EAAP;AACD;AArGS;;AAAA;AAAA,IAAiBtB,MAAjB,CAAL,EAuGJC,KAvGH;AAwGD;;AAED,SAASuB,WAAT,CAAqBxB,MAArB,EAA6B;AAC3B;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AACE;AACJ;AACA;AACA;AACA;AALE;AAAA,gFAME;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACQ,KAAKtB,KAAL,CAAW,SAAX,CADR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SANF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,IAAqBsB,MAArB;AAWD;;AAED,SAASyB,iBAAT,CAA2BjF,GAA3B,EAAgCC,GAAhC,EAAqCrD,KAArC,EAA4C;AAAE,MAAIqD,GAAG,IAAID,GAAX,EAAgB;AAAEtD,IAAAA,MAAM,CAACwD,cAAP,CAAsBF,GAAtB,EAA2BC,GAA3B,EAAgC;AAAErD,MAAAA,KAAK,EAAEA,KAAT;AAAgBuD,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWrD,KAAX;AAAmB;;AAAC,SAAOoD,GAAP;AAAa;;AAEnN,IAAMkF,eAAe,GAAG,SAAlBA,eAAkB,CAAA3H,OAAO,EAAI;AACjC,MAAI,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EAAqD;AACnD,UAAM,IAAIW,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,MAAMiH,kBAAkB,GAAG7H,qBAAqB,CAACC,OAAD,CAAhD;AACA,MACEsB,OADF,GAIItB,OAJJ,CACEsB,OADF;AAAA,MAEEE,MAFF,GAIIxB,OAJJ,CAEEwB,MAFF;AAAA,MAGED,eAHF,GAIIvB,OAJJ,CAGEuB,eAHF,CANiC,CAUpB;;AAEb,MAAI,OAAOD,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAACZ,MAAR,KAAmB,CAAtD,EAAyD;AACvD,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,MAAIa,MAAM,KAAKZ,SAAX,KAAyB,CAACY,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAAtD,CAAJ,EAAqE;AACnE,UAAM,IAAIb,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED,MAAIY,eAAe,KAAKX,SAApB,IAAiC,OAAOW,eAAP,KAA2B,QAAhE,EAA0E;AACxE,UAAM,IAAIZ,KAAJ,CAAU,wDAAV,CAAN;AACD;;AAED,yCAAYiH,kBAAZ;AACEtG,IAAAA,OAAO,EAAPA,OADF;AAEEE,IAAAA,MAAM,EAANA,MAFF;AAGED,IAAAA,eAAe,EAAfA;AAHF;AAKD,CA7BD;;IA+BMsG,gB;;;;;AACJ;AACA,4BAAY7H,OAAZ,EAAqB;AAAA;;AAAA;;AACnB;;AAEA0H,IAAAA,iBAAiB,iCAAO,MAAP,EAAe,gBAAf,CAAjB;;AAEAA,IAAAA,iBAAiB,iCAAO,QAAP,EAAiB;AAChC/B,MAAAA,IAAI,EAAE,qIAD0B;AAEhCxC,MAAAA,MAAM,EAAE;AAFwB,KAAjB,CAAjB;;AAKAuE,IAAAA,iBAAiB,iCAAO,QAAP,EAAiB;AAChCzC,MAAAA,KAAK,EAAE,SADyB;AAEhCK,MAAAA,IAAI,EAAE;AAF0B,KAAjB,CAAjB;;AAKAoC,IAAAA,iBAAiB,iCAAO,SAAP,EAAkB,KAAK,CAAvB,CAAjB;;AAEA,WAAK1H,OAAL,GAAe2H,eAAe,CAAC3H,OAAD,CAA9B;AAjBmB;AAkBpB;;;;WAED,uBAAc;AACZ,aAAOmB,WAAW,CAAC,KAAKnB,OAAN,CAAlB;AACD;;;;EAxB4B+C,a;AA2B/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGM+E,K;;;;;;;;;;;;;;AACJ;AACF;AACA;AACA;;yFACE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKnD,KAAL,CAAW,KAAX,EAAkB,aAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAEEiC,gBAAAA,OAAO,CAACC,IAAR,CAAa,6JAAb;AAFF,mDAGS,OAAOlC,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAH/C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAKA;AACF;AACA;AACA;AACA;AACA;;;;;yFAGE,mBAAyBzF,KAAzB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QADvB;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,mDAAf,CAFX;;AAAA;AAKE+B,gBAAAA,OAAO,CAACC,IAAR,CAAa,6JAAb;AALF;AAAA,uBAMQ,KAAKnC,KAAL,CAAW,KAAX,EAAkB,aAAlB,EAAiCtF,KAAjC,CANR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAQA;AACF;AACA;;;;;gFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKsF,KAAL,CAAW,KAAX,EAAkB,QAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAES,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAAzC,GAAgDA,MAAhD,GAAyDC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAFlE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;AACA;AACA;AACA;;;;;gFAGE,mBAAgBzF,KAAhB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+CI,KAAK,CAACC,OAAN,CAAcL,KAAd,CADrD;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,2CAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,QAAlB,EAA4BlG,KAAK,CAACiD,SAAN,CAAgBrC,KAAhB,EAAuB;AACvDsC,kBAAAA,OAAO,EAAE;AAD8C,iBAAvB,CAA5B,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AASA;AACF;AACA;;;;;mFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKgD,KAAL,CAAW,KAAX,EAAkB,WAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAES,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAAzC,GAAgDA,MAAhD,GAAyDC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAFlE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;;;;;mFAGE,mBAAmBzF,KAAnB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+CI,KAAK,CAACC,OAAN,CAAcL,KAAd,CADrD;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,8CAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,WAAlB,EAA+BlG,KAAK,CAACiD,SAAN,CAAgBrC,KAAhB,EAAuB;AAC1DsC,kBAAAA,OAAO,EAAE;AADiD,iBAAvB,CAA/B,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAUA,wBAAeuD,WAAf,EAA4B;AAC1B,aAAO,0EAAqBA,WAArB,EAAkCC,EAAlC,CAAqC,OAArC,EAA8C,KAAK4C,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAA9C,CAAP;AACD;AACD;AACF;AACA;;;;;8EAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKrD,KAAL,CAAW,KAAX,EAAkB,MAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAES,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAAzC,GAAgDA,MAAhD,GAAyDC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAFlE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EAxFkB2C,WAAW,CAACzB,WAAW,CAAC6B,gBAAD,CAAZ,C;;IA+FzBI,yB;AACJ,qCAAY3G,OAAZ,EAAqB4G,SAArB,EAAgC;AAAA;;AAC9B,SAAK5G,OAAL,GAAeA,OAAf;AACA,SAAK4G,SAAL,GAAiBA,SAAjB;AACD;AACD;AACF;AACA;;;;;WAGE,eAAMC,OAAN,EAA2B;AAAA;;AAAA,yCAAT1C,OAAS;AAATA,QAAAA,OAAS;AAAA;;AACzB,aAAO,wBAAKyC,SAAL,EAAevD,KAAf,yBAAqBwD,OAArB,SAAiC1C,OAAjC,GAA0C,KAAKnE,OAA/C,GAAP;AACD;;;;;;IAIG8G,c;;;;;;;;;;;;EAAuBX,WAAW,CAACzB,WAAW,CAACiC,yBAAD,CAAZ,C;;AAExC,SAASI,iBAAT,CAA2B5F,GAA3B,EAAgCC,GAAhC,EAAqCrD,KAArC,EAA4C;AAAE,MAAIqD,GAAG,IAAID,GAAX,EAAgB;AAAEtD,IAAAA,MAAM,CAACwD,cAAP,CAAsBF,GAAtB,EAA2BC,GAA3B,EAAgC;AAAErD,MAAAA,KAAK,EAAEA,KAAT;AAAgBuD,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWrD,KAAX;AAAmB;;AAAC,SAAOoD,GAAP;AAAa;;AAEnN,IAAM6F,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAtI,OAAO,EAAI;AACrC,MAAI,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EAAqD;AACnD,UAAM,IAAIW,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,MAAMiH,kBAAkB,GAAG7H,qBAAqB,CAACC,OAAD,CAAhD;AACA,MACE+B,WADF,GAMI/B,OANJ,CACE+B,WADF;AAAA,MAEEI,gBAFF,GAMInC,OANJ,CAEEmC,gBAFF;AAAA,MAGEF,SAHF,GAMIjC,OANJ,CAGEiC,SAHF;AAAA,MAIEC,UAJF,GAMIlC,OANJ,CAIEkC,UAJF;AAAA,MAKEF,gBALF,GAMIhC,OANJ,CAKEgC,gBALF,CANqC,CAYxB;;AAEb,MAAI,OAAOD,WAAP,KAAuB,QAAvB,IAAmCA,WAAW,CAACrB,MAAZ,KAAuB,CAA9D,EAAiE;AAC/D,UAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,MAAIwB,gBAAgB,KAAKvB,SAArB,IAAkC,OAAOuB,gBAAP,KAA4B,QAAlE,EAA4E;AAC1E,UAAM,IAAIxB,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,MAAIsB,SAAS,KAAKrB,SAAd,IAA2B,OAAOqB,SAAP,KAAqB,QAApD,EAA8D;AAC5D,UAAM,IAAItB,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAIsB,SAAS,KAAKrB,SAAd,IAA2BqB,SAAS,KAAKnC,YAAY,CAACyI,KAAtD,IAA+DtG,SAAS,KAAKnC,YAAY,CAAC0I,KAA9F,EAAqG;AACnG,UAAM,IAAI7H,KAAJ,+BAAgCb,YAAY,CAACyI,KAA7C,qBAA2DzI,YAAY,CAAC0I,KAAxE,QAAN;AACD;;AAED,MAAItG,UAAU,KAAKtB,SAAf,IAA4B,OAAOsB,UAAP,KAAsB,QAAtD,EAAgE;AAC9D,UAAM,IAAIvB,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,MAAIuB,UAAU,KAAKtB,SAAf,IAA4BsB,UAAU,KAAKpC,YAAY,CAACyI,KAAxD,IAAiErG,UAAU,KAAKpC,YAAY,CAAC0I,KAAjG,EAAwG;AACtG,UAAM,IAAI7H,KAAJ,gCAAiCb,YAAY,CAACyI,KAA9C,qBAA4DzI,YAAY,CAAC0I,KAAzE,QAAN;AACD;;AAED,MAAIxG,gBAAgB,KAAKpB,SAArB,IAAkC,OAAOoB,gBAAP,KAA4B,SAAlE,EAA6E;AAC3E,UAAM,IAAIrB,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,yCAAYiH,kBAAZ;AACE7F,IAAAA,WAAW,EAAXA,WADF;AAEEI,IAAAA,gBAAgB,EAAhBA,gBAFF;AAGEF,IAAAA,SAAS,EAATA,SAHF;AAIEC,IAAAA,UAAU,EAAVA,UAJF;AAKEF,IAAAA,gBAAgB,EAAhBA;AALF;AAOD,CAjDD;;IAmDMyG,oB;;;;;AACJ;AACA,gCAAYzI,OAAZ,EAAqB;AAAA;;AAAA;;AACnB;;AAEAqI,IAAAA,iBAAiB,iCAAO,MAAP,EAAe,oBAAf,CAAjB;;AAEAA,IAAAA,iBAAiB,iCAAO,QAAP,EAAiB;AAChC1C,MAAAA,IAAI,EAAE,iJAD0B;AAEhCxC,MAAAA,MAAM,EAAE;AAFwB,KAAjB,CAAjB;;AAKAkF,IAAAA,iBAAiB,iCAAO,QAAP,EAAiB;AAChCpD,MAAAA,KAAK,EAAE,SADyB;AAEhCK,MAAAA,IAAI,EAAE;AAF0B,KAAjB,CAAjB;;AAKA+C,IAAAA,iBAAiB,iCAAO,SAAP,EAAkB,KAAK,CAAvB,CAAjB;;AAEA,WAAKrI,OAAL,GAAesI,mBAAmB,CAACtI,OAAD,CAAlC;AAjBmB;AAkBpB;;;;WAED,uBAAc;AACZ,aAAO8B,eAAe,CAAC,KAAK9B,OAAN,CAAtB;AACD;;;;EAxBgC+C,a;AA2BnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGM2F,S;;;;;AACJ,uBAAqB;AAAA;;AAAA;;AAAA,uCAANvC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACnB,uDAASA,IAAT;;AAEAkC,IAAAA,iBAAiB,iCAAO,QAAP,EAAiB,EAAjB,CAAjB;;AAHmB;AAIpB;AAED;AACF;AACA;;;;;;0FACE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAK1D,KAAL,CAAW,KAAX,EAAkB,kBAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAES,OAAOA,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAF/C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;AACA;;;;;0FAGE,mBAA0BzF,KAA1B;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,QADvB;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,oDAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,kBAAlB,EAAsCtF,KAAtC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;;;;;wFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKsF,KAAL,CAAW,KAAX,EAAkB,aAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAES,OAAOA,MAAP,KAAkB,SAAlB,GAA8BnB,OAAO,CAACmB,MAAD,CAArC,GAAgDC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAFzD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;;;;;yFAGE,mBAAyBzF,KAAzB;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAOA,KAAP,KAAiB,SADvB;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,oDAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,aAAlB,EAAiCtF,KAAjC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;;;;;mFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKsF,KAAL,CAAW,KAAX,EAAkB,cAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAESA,MAAM,KAAK9E,YAAY,CAACyI,KAAxB,IAAiC3D,MAAM,KAAK9E,YAAY,CAAC0I,KAAzD,GAAiE5D,MAAjE,GAA0EC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAFnF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;;;;;mFAGE,mBAAmBzF,KAAnB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACO,CAAC,OAAD,EAAU,OAAV,EAAmBwB,QAAnB,CAA4BxB,KAA5B,CADP;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,yEAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,cAAlB,EAAkCtF,KAAlC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;;;;;oFAGE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACyB,KAAKsF,KAAL,CAAW,KAAX,EAAkB,eAAlB,CADzB;;AAAA;AAAA;AAAA;AACSC,gBAAAA,MADT;AAAA,mDAESA,MAAM,KAAK,OAAX,IAAsBA,MAAM,KAAK,OAAjC,GAA2CA,MAA3C,GAAoDC,OAAO,CAACC,MAAR,CAAe,0CAAf,CAF7D;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACF;AACA;;;;;oFAGE,mBAAoBzF,KAApB;AAAA;AAAA;AAAA;AAAA;AAAA,oBACO,CAAC,OAAD,EAAU,OAAV,EAAmBwB,QAAnB,CAA4BxB,KAA5B,CADP;AAAA;AAAA;AAAA;;AAAA,mDAEWwF,OAAO,CAACC,MAAR,CAAe,0EAAf,CAFX;;AAAA;AAAA;AAAA,uBAKQ,KAAKH,KAAL,CAAW,KAAX,EAAkB,eAAlB,EAAmCtF,KAAnC,CALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAOA;AACF;AACA;;;;;+EAGE,mBAAeoH,EAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBACO,KAAKkC,MAAL,CAAYlC,EAAZ,CADP;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAE6B,KAAK9B,KAAL,CAAW,KAAX,EAAkB,QAAlB,EAA4B,CAAC8B,EAAD,CAA5B,CAF7B;;AAAA;AAAA;AAAA;AAEWmC,gBAAAA,QAFX;;AAAA,oBAISnJ,KAAK,CAACC,OAAN,CAAckJ,QAAd,CAJT;AAAA;AAAA;AAAA;;AAAA,mDAKa/D,OAAO,CAACC,MAAR,CAAe,0CAAf,CALb;;AAAA;AAAA,sBAQQ8D,QAAQ,CAAClI,MAAT,KAAoB,CAR5B;AAAA;AAAA;AAAA;;AAAA,mDASamE,OAAO,CAACC,MAAR,CAAe,uBAAuB2B,EAAtC,CATb;;AAAA;AAYI,qBAAKkC,MAAL,CAAYlC,EAAZ,IAAkB,IAAI2B,cAAJ,CAAmB3B,EAAnB,EAAuB,IAAvB,CAAlB;;AAZJ;AAAA,mDAeS,KAAKkC,MAAL,CAAYlC,EAAZ,CAfT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAiBA;AACF;AACA;;;;;mFAGE;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC2B,KAAK9B,KAAL,CAAW,KAAX,EAAkB,QAAlB,CAD3B;;AAAA;AAAA;AAAA;AACSiE,gBAAAA,QADT;;AAAA,oBAGOnJ,KAAK,CAACC,OAAN,CAAckJ,QAAd,CAHP;AAAA;AAAA;AAAA;;AAAA,mDAIW/D,OAAO,CAACC,MAAR,CAAe,0CAAf,CAJX;;AAAA;AAOQ6D,gBAAAA,MAPR,GAOiB,EAPjB;AAQEC,gBAAAA,QAAQ,CAACC,OAAT,CAAiB,UAAApC,EAAE,EAAI;AACrB,sBAAI,CAAC,MAAI,CAACkC,MAAL,CAAYlC,EAAZ,CAAL,EAAsB;AACpB,oBAAA,MAAI,CAACkC,MAAL,CAAYlC,EAAZ,IAAkB,IAAI2B,cAAJ,CAAmB3B,EAAnB,EAAuB,MAAvB,CAAlB;AACD;;AAEDkC,kBAAAA,MAAM,CAACG,IAAP,CAAY,MAAI,CAACH,MAAL,CAAYlC,EAAZ,CAAZ;AACD,iBAND;AARF,mDAeSkC,MAfT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAkBA,wBAAezD,WAAf,EAA4B;AAAA;;AAC1B,aAAO,8EAAqBA,WAArB,EAAkCC,EAAlC,CAAqC,OAArC,EAA8C,UAACkB,KAAD,EAAQZ,OAAR,EAAiBa,UAAjB,EAAgC;AACnF,YAAMhF,OAAO,GAAGmE,OAAO,CAACnE,OAAxB;;AAEA,QAAA,MAAI,CAACqH,MAAL,CAAYrH,OAAZ,EAAqByG,YAArB,CAAkC1B,KAAlC,EAAyCZ,OAAzC,EAAkDa,UAAlD;AACD,OAJM,CAAP;AAKD;;;;EA7IqBmB,WAAW,CAACgB,oBAAD,C,GAiJnC;AACA;AACA;AACA;;;AACA,IAAMM,YAAY,GAAG,SAAfA,YAAe,CAAAC,GAAG,EAAI;AAC1B,MAAI;AACF,qBAAqCA,GAAG,CAACC,KAAJ,CAAU,GAAV,CAArC;AAAA;AAAA,QAAOC,MAAP;AAAA,QAAezD,OAAf;AAAA,QAAwB0D,SAAxB;;AACA,sBAEIC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAAC7D,OAAD,CAAf,CAFJ;AAAA,QACE8D,GADF,eACEA,GADF,CAFE,CAI6B;;;AAE/B,WAAOzD,IAAI,CAACC,GAAL,KAAa,IAAb,IAAqBwD,GAAG,GAAG,GAAlC;AACD,GAPD,CAOE,OAAO1H,CAAP,EAAU;AACV,UAAM,IAAIlB,KAAJ,CAAU,wEAAV,CAAN;AACD;AACF,CAXD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SAGe6I,iB;;;;;gFAAf,mBAAiCC,eAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,YAAAA,MADR,GACiBD,eADjB;;AAAA,kBAGM,CAACC,MAAM,CAACC,IAAR,IAAgB,CAACD,MAAM,CAACC,IAAP,CAAYC,QAHnC;AAAA;AAAA;AAAA;;AAAA,kBAIU,IAAIjJ,KAAJ,CAAU,kCAAV,CAJV;;AAAA;AAAA,gBAOO+I,MAAM,CAACC,IAAP,CAAYE,UAPnB;AAAA;AAAA;AAAA;;AAAA,kBAQU,IAAIlJ,KAAJ,CAAU,kFAAV,CARV;;AAAA;AAAA,gBAWO+I,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBE,WAX5B;AAAA;AAAA;AAAA;;AAAA,kBAYU,IAAInJ,KAAJ,CAAU,uEAAV,CAZV;;AAAA;AAAA,iBAeMoI,YAAY,CAACW,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBE,WAAtB,CAflB;AAAA;AAAA;AAAA;;AAAA,iBAiBQJ,MAAM,CAACC,IAAP,CAAYI,iBAjBpB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAkBYL,MAAM,CAACC,IAAP,CAAYI,iBAAZ,EAlBZ;;AAAA;AAAA;AAAA;;AAAA;AAAA,iBAmBeL,MAAM,CAACC,IAAP,CAAYK,kBAnB3B;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAoBYN,MAAM,CAACC,IAAP,CAAYK,kBAAZ,EApBZ;;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAsBY,IAAIrJ,KAAJ,CAAU,2DAAV,CAtBZ;;AAAA;AAAA,+CA0BS+I,MAAM,CAACC,IAAP,CAAYC,QAAZ,CAAqBE,WA1B9B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA6BA,SAASG,iBAAT,CAA2BxH,GAA3B,EAAgCC,GAAhC,EAAqCrD,KAArC,EAA4C;AAAE,MAAIqD,GAAG,IAAID,GAAX,EAAgB;AAAEtD,IAAAA,MAAM,CAACwD,cAAP,CAAsBF,GAAtB,EAA2BC,GAA3B,EAAgC;AAAErD,MAAAA,KAAK,EAAEA,KAAT;AAAgBuD,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEL,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWrD,KAAX;AAAmB;;AAAC,SAAOoD,GAAP;AAAa;AACnN;AACA;AACA;;;IAEMyH,Q;AACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,oBAAYlK,OAAZ,EAAqB;AAAA;;AACnBiK,IAAAA,iBAAiB,CAAC,IAAD,EAAO,gBAAP,EAAyB,KAAK,CAA9B,CAAjB;;AAEA,SAAKE,cAAL,GAAsBnK,OAAtB;AACD;AACD;AACF;AACA;AACA;;;;;WAGE,qBAAYA,OAAZ,EAAqB;AACnB,aAAO,IAAI8H,KAAJ,iCAAe,KAAKqC,cAApB,GACFnK,OADE,EAAP;AAGD;AACD;AACF;AACA;AACA;;;;WAGE,yBAAgBA,OAAhB,EAAyB;AACvB,aAAO,IAAI0I,SAAJ,iCAAmB,KAAKyB,cAAxB,GACFnK,OADE,EAAP;AAGD;;;;;;AAIH,eAAekK,QAAf;AACA,SAASV,iBAAT","sourcesContent":["import { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty';\nimport _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty';\n\n// Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\nfunction createElement(name, props = {}, children = []) {\n  const element = document.createElement(name);\n\n  for (const [name, value] of Object.entries(props)) {\n    if (name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  for (const child of Array.isArray(children) ? children : [children]) {\n    element.append(child);\n  }\n\n  return element;\n}\n\n/**\n * Shared options for embedding\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createChart}.\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createDashboard}.\n */\n//TODO find a way to reuse types defined in \"packages/charts-frontend/src/utils/chart/events/event-payload-types.ts\"\nlet THEME_ENUM;\n\n(function (THEME_ENUM) {\n  THEME_ENUM[\"DARK\"] = \"dark\";\n  THEME_ENUM[\"LIGHT\"] = \"light\";\n})(THEME_ENUM || (THEME_ENUM = {}));\n\nlet SCALING_ENUM;\n\n(function (SCALING_ENUM) {\n  SCALING_ENUM[\"FIXED\"] = \"fixed\";\n  SCALING_ENUM[\"SCALE\"] = \"scale\";\n})(SCALING_ENUM || (SCALING_ENUM = {}));\n\n/**\n * Retrieve embed options that are shared.\n *\n * Validates the values passed in as well.\n */\nconst getSharedEmbedOptions = options => {\n  const {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  } = options;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  return {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  };\n};\nconst getPathname = (url, pathname) => {\n  return [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', // Add trailing slash if not there\n  pathname].join('');\n};\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\n\nconst getChartUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/charts');\n    url.search = `id=${options.chartId}&sdk=2`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autorefresh=false`;\n    } else if (options.autoRefresh === undefined) {\n      url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.filter) {\n      url.search += `&filter=${encodeURIComponent(EJSON.stringify(options.filter, {\n        relaxed: false\n      }))}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/**\n * Constructs the dashboard iframe URL from the baseUrl, dashboardId & tenantId\n */\n\nconst getDashboardUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/dashboards');\n    url.search = `id=${options.dashboardId}&sdk=1`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autoRefresh=false`;\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.showTitleAndDesc === true) {\n      url.search += `&showTitleAndDesc=true`;\n    }\n\n    if (options.widthMode) {\n      url.search += `&scalingWidth=${options.widthMode}`;\n    }\n\n    if (options.heightMode) {\n      url.search += `&scalingHeight=${options.heightMode}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.chartsBackground) {\n      url.search += `&chartsBackground=${options.chartsBackground}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/*\n  Parses a CSS Measurement from an unknown value\n  - if it's a string, we trust that it is well-formed\n  - if it's a number, we assume the units are pixels\n  - otherwise we return null\n*/\n\nconst parseCSSMeasurement = value => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return `${value}px`;\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\nconst getBackground = (background, theme, lightBackground, darkBackground) => {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return darkBackground;\n  return lightBackground;\n};\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass BaseEmbedItem {\n  constructor() {\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ERRORS\", void 0);\n\n    _defineProperty(this, \"COLOUR\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n  }\n\n  /**\n   * Renders an embeddable item into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the item has successfully been embedded\n   */\n  async render(container) {\n    if (this.iframe) {\n      throw new Error(this.ERRORS.IFRAME);\n    } // Create styled container\n\n\n    const embedRoot = this._configureEmbedRoot(createElement('div', {\n      style: {\n        position: 'relative',\n        overflow: 'hidden',\n        minHeight: Boolean(this.options.height) ? 0 : '15px',\n        width: parseCSSMeasurement(this.options.width) || '100%',\n        height: parseCSSMeasurement(this.options.height) || '100%'\n      }\n    })); // Create host\n\n\n    const host = this._configureHost(Chatty.createHost(this.getEmbedUrl()).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot)).build(); // Customise IFrame styles\n\n\n    host.iframe.setAttribute('aria-label', this.name);\n    Object.assign(host.iframe.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      border: 0,\n      width: '100%',\n      height: '100%'\n    }); // Remove any existing nodes in our target container\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    container.appendChild(embedRoot); // connect to iframe\n\n    this.connection = await host.connect();\n    this.iframe = host.iframe;\n\n    this._setBackground(this.options.background, this.options.theme); // configure token if needed\n\n\n    await this._retrieveAndSetToken(); // Ready to actually render Embedded Item\n\n    await this._send('ready');\n  }\n  /**\n   * @returns whether auto refreshing is enabled\n   */\n\n\n  async isAutoRefresh() {\n    const [result] = await this._send('get', 'autoRefresh'); // autoRefresh from embed chart may be a number when refreshInterval is set\n\n    return typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable auto refreshing.\n   */\n\n\n  async setAutoRefresh(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('autoRefresh property value should be a boolean');\n    }\n\n    await this._send('set', 'autoRefresh', value);\n  }\n  /**\n   * @returns the number of seconds before a chart or dashboard's data expires\n   */\n\n\n  async getMaxDataAge() {\n    const [result] = await this._send('get', 'maxDataAge');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart or dashboard's data expires.\n   */\n\n\n  async setMaxDataAge(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('maxDataAge property value should be a number');\n    }\n\n    await this._send('set', 'maxDataAge', value);\n  }\n  /**\n   * Sets the color scheme to apply to the chart or dashboard.\n   *\n   * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n   */\n\n\n  async setTheme(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('theme property value should be a string');\n    } // if invalid theme string is provided, default it to light\n\n\n    const newTheme = Object.values(THEME_ENUM).includes(value) ? value : THEME_ENUM.LIGHT;\n    await this._send('set', 'theme', newTheme);\n\n    this._setBackground(this.options.background, newTheme);\n  }\n  /**\n   * @returns the current theme applied to the chart or dashboard\n   */\n\n\n  async getTheme() {\n    const [result] = await this._send('get', 'theme');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n  _configureHost(hostBuilder) {\n    return hostBuilder.on('refreshToken', () => this._retrieveAndSetToken());\n  }\n\n  _configureEmbedRoot(embedRoot) {\n    return embedRoot;\n  }\n\n  _setBackground(background, theme) {\n    this.iframe.style.backgroundColor = getBackground(background, theme, this.COLOUR.LIGHT, this.COLOUR.DARK);\n  }\n\n  async _retrieveAndSetToken() {\n    if (this.options.getUserToken) {\n      const token = await this.options.getUserToken();\n      await this._send('set', 'token', token);\n    }\n  }\n  /**\n   * Send message to embedded app.\n   */\n\n\n  _send(eventName, ...payload) {\n    if (this.connection) {\n      return this.connection.sendAndReceive(eventName, ...payload);\n    }\n\n    return Promise.reject(this.ERRORS.SEND);\n  }\n\n}\n\nfunction _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nlet eventHandlerIndex = Date.now();\nfunction EventSource(Sender) {\n  var _temp;\n\n  return _temp = class extends Sender {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty$1(this, \"_eventHandlers\", {\n        click: {} // refresh: {} To be added soon\n\n      });\n    }\n\n    /**\n     * Handle the event sent from embedded app.\n     */\n    _handleEvent(event, payload, handlerIds) {\n      const handlers = this._eventHandlers[event];\n\n      for (const id of handlerIds) {\n        try {\n          var _handlers$id;\n\n          // since communication between host and SDK is async,\n          // it's possible that some handlers have been removed;\n          // thus needs to check if handler still exists before calling\n          (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n        } catch (error) {\n          console.warn(`Error calling handler for event [${event}]: ${error}`);\n        }\n      }\n    }\n    /**\n     * Sets an event listener\n     * @param event - the event you are subscribing to\n     * @param eventHandler - the callback to be executed when the event is triggered\n     * @param options - optional options object, can be used to customise when handler is called\n     */\n\n\n    addEventListener(event, eventHandler, options) {\n      var _h$options$includes;\n\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n\n      if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(f => _isEmpty(f))) {\n        // eslint-disable-next-line no-console\n        console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n      } // ignore if same handler and options have been added already\n\n\n      if (!Object.keys(handlers).some(id => _isEqual(handlers[id], h))) {\n        const handlerId = (++eventHandlerIndex).toString(36);\n        handlers[handlerId] = h;\n        return this._send('eventHandler', event, {\n          handlerId,\n          options: h.options\n        });\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Removes an event listener\n     * @param event - the event you are unsubscribing from\n     * @param eventHandler - the event listener function you are unsubscribing from\n     * @param options - optional options object used when addEventListener\n     */\n\n\n    removeEventListener(event, eventHandler, options) {\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n      const handlerId = Object.keys(handlers).find(id => _isEqual(handlers[id], h));\n\n      if (handlerId) {\n        delete handlers[handlerId];\n        return this._send('eventHandler', event, {\n          handlerId\n        });\n      }\n\n      return Promise.resolve();\n    }\n\n  }, _temp;\n}\n\nfunction Refreshable(Sender) {\n  return class extends Sender {\n    /**\n     * Triggers a refresh of the chart or dashboard (if it has been embedded).\n     *\n     * @returns a promise that resolves once the chart or dashboard updated its data\n     */\n    async refresh() {\n      await this._send('refresh');\n    }\n\n  };\n}\n\nfunction _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst getChartOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    chartId,\n    filter,\n    refreshInterval\n  } = options; // Verify chart embed options\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    chartId,\n    filter,\n    refreshInterval\n  };\n};\n\nclass ChartEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$2(this, \"name\", 'Embedded Chart');\n\n    _defineProperty$2(this, \"ERRORS\", {\n      SEND: 'Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.',\n      IFRAME: 'A chart can only be rendered into a container once'\n    });\n\n    _defineProperty$2(this, \"COLOUR\", {\n      LIGHT: '#FFFFFF',\n      DARK: '#21313C'\n    });\n\n    _defineProperty$2(this, \"options\", void 0);\n\n    this.options = getChartOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getChartUrl(this.options);\n  }\n\n}\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\n\nclass Chart extends Refreshable(EventSource(ChartEventSender)) {\n  /**\n   * @returns the number of seconds a chart will wait before refreshing\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n  async getRefreshInterval() {\n    const [result] = await this._send('get', 'autorefresh');\n    console.warn(\"The 'getRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart will wait before refreshing.\n   *\n   * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n\n\n  async setRefreshInterval(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('refreshInterval property value should be a number');\n    }\n\n    console.warn(\"The 'setRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the current filter applied to the embedded chart.\n   */\n\n\n  async getFilter() {\n    const [result] = await this._send('get', 'filter');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the filter to apply to the embedded chart.\n   *\n   * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n   * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n   */\n\n\n  async setFilter(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('filter property value should be an object');\n    }\n\n    await this._send('set', 'filter', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * @returns the current highlight applied to the embedded chart.\n   */\n\n\n  async getHighlight() {\n    const [result] = await this._send('get', 'highlight');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the highlight to apply to the embedded chart.\n   *\n   * This is the exact same object that can be used in 'setFilter'.\n   * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n   * @param value The highlight object to be applied to the chart\n   */\n\n\n  async setHighlight(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('highlight property value should be an object');\n    }\n\n    await this._send('set', 'highlight', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', this._handleEvent.bind(this));\n  }\n  /**\n   * @returns the data of the embedded chart.\n   */\n\n\n  async getData() {\n    const [result] = await this._send('get', 'data');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n}\n\nclass DashboardChartEventSender {\n  constructor(chartId, dashboard) {\n    this.chartId = chartId;\n    this.dashboard = dashboard;\n  }\n  /**\n   * Send message to embedded app via dashboard.\n   */\n\n\n  _send(msgName, ...payload) {\n    return this.dashboard._send(msgName, ...payload, this.chartId);\n  }\n\n}\n\nclass DashboardChart extends Refreshable(EventSource(DashboardChartEventSender)) {}\n\nfunction _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst getDashboardOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  } = options; // Verify dashboard embed options\n\n  if (typeof dashboardId !== 'string' || dashboardId.length === 0) {\n    throw new Error('dashboardId must be specified');\n  }\n\n  if (chartsBackground !== undefined && typeof chartsBackground !== 'string') {\n    throw new Error('chartsBackground must be a string if specified');\n  }\n\n  if (widthMode !== undefined && typeof widthMode !== 'string') {\n    throw new Error('widthMode must be a string if specified');\n  }\n\n  if (widthMode !== undefined && widthMode !== SCALING_ENUM.FIXED && widthMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`widthMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (heightMode !== undefined && typeof heightMode !== 'string') {\n    throw new Error('heightMode must be a string if specified');\n  }\n\n  if (heightMode !== undefined && heightMode !== SCALING_ENUM.FIXED && heightMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`heightMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (showTitleAndDesc !== undefined && typeof showTitleAndDesc !== 'boolean') {\n    throw new Error('showTitleAndDesc must be a boolean value if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  };\n};\n\nclass DashboardEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$3(this, \"name\", 'Embedded Dashboard');\n\n    _defineProperty$3(this, \"ERRORS\", {\n      SEND: 'Dashboard has not been rendered. Ensure that you wait for the promise returned by `dashboard.render()` before trying to manipulate a dashboard.',\n      IFRAME: 'A dashboard can only be rendered into a container once'\n    });\n\n    _defineProperty$3(this, \"COLOUR\", {\n      LIGHT: '#F1F5F4',\n      DARK: '#12212C'\n    });\n\n    _defineProperty$3(this, \"options\", void 0);\n\n    this.options = getDashboardOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getDashboardUrl(this.options);\n  }\n\n}\n/**\n * # Dashboard\n *\n * Allows you to interact and embed dashboards into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const dashboard = sdk.createDashboard({ ... });\n *\n * // renders a dashboard\n * dashboard.render(document.getElementById('embed-dashboard'));\n *\n * ```\n */\n\n\nclass Dashboard extends Refreshable(DashboardEventSender) {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty$3(this, \"charts\", {});\n  }\n\n  /**\n   * @returns current chartsBackground or empty string if not set\n   */\n  async getChartsBackground() {\n    const [result] = await this._send('get', 'chartsBackground');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set a custom background color for all charts.\n   * To clear existing value, set it to empty string.\n   */\n\n\n  async setChartsBackground(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('chartsBackground property value should be a string');\n    }\n\n    await this._send('set', 'chartsBackground', value);\n  }\n  /**\n   * @returns whether attribution logo should be shown\n   */\n\n\n  async isShowAttribution() {\n    const [result] = await this._send('get', 'attribution');\n    return typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable attribution logo.\n   */\n\n\n  async setShowAttribution(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('showAttribution property value should be a boolean');\n    }\n\n    await this._send('set', 'attribution', value);\n  }\n  /**\n   * @returns get width scaling mode of embedded dashboard\n   */\n\n\n  async getWidthMode() {\n    const [result] = await this._send('get', 'scalingWidth');\n    return result === SCALING_ENUM.FIXED || result === SCALING_ENUM.SCALE ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set width scaling mode for embedded dashboard\n   */\n\n\n  async setWidthMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('widthMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingWidth', value);\n  }\n  /**\n   * @returns get height scaling mode of embedded dashboard\n   */\n\n\n  async getHeightMode() {\n    const [result] = await this._send('get', 'scalingHeight');\n    return result === 'fixed' || result === 'scale' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set height scaling mode for embedded dashboard\n   */\n\n\n  async setHeightMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('heightMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingHeight', value);\n  }\n  /**\n   * @returns get the dashboard chart with specified id\n   */\n\n\n  async getChart(id) {\n    if (!this.charts[id]) {\n      const [chartIds] = await this._send('get', 'charts', [id]);\n\n      if (!Array.isArray(chartIds)) {\n        return Promise.reject('unexpected response received from iframe');\n      }\n\n      if (chartIds.length !== 1) {\n        return Promise.reject('Invalid chart id: ' + id);\n      }\n\n      this.charts[id] = new DashboardChart(id, this);\n    }\n\n    return this.charts[id];\n  }\n  /**\n   * @returns all charts on the dashboard\n   */\n\n\n  async getAllCharts() {\n    const [chartIds] = await this._send('get', 'charts');\n\n    if (!Array.isArray(chartIds)) {\n      return Promise.reject('unexpected response received from iframe');\n    }\n\n    const charts = [];\n    chartIds.forEach(id => {\n      if (!this.charts[id]) {\n        this.charts[id] = new DashboardChart(id, this);\n      }\n\n      charts.push(this.charts[id]);\n    });\n    return charts;\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', (event, payload, handlerIds) => {\n      const chartId = payload.chartId;\n\n      this.charts[chartId]._handleEvent(event, payload, handlerIds);\n    });\n  }\n\n}\n\n// Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\nconst isJWTExpired = jwt => {\n  try {\n    const [header, payload, signature] = jwt.split('.');\n    const {\n      exp\n    } = JSON.parse(atob(payload)); // Check the current time against the expiry (minus 5 minutes) in the token\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nasync function getRealmUserToken(stitchAppClient) {\n  const client = stitchAppClient;\n\n  if (!client.auth || !client.auth.authInfo) {\n    throw new Error('Unfamiliar Stitch client version');\n  }\n\n  if (!client.auth.isLoggedIn) {\n    throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n  }\n\n  if (!client.auth.authInfo.accessToken) {\n    throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n  }\n\n  if (isJWTExpired(client.auth.authInfo.accessToken)) {\n    // Attempt to refresh token using progression from public -> private apis\n    if (client.auth.refreshCustomData) {\n      await client.auth.refreshCustomData(); // supported from 4.8.0\n    } else if (client.auth.refreshAccessToken) {\n      await client.auth.refreshAccessToken(); // supported from 4.0.0\n    } else {\n      throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n    }\n  }\n\n  return client.auth.authInfo.accessToken;\n}\n\nfunction _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * Creates an instance of the embedding SDK\n */\n\nclass EmbedSDK {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  constructor(options) {\n    _defineProperty$4(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  createChart(options) {\n    return new Chart({ ...this.defaultOptions,\n      ...options\n    });\n  }\n  /**\n   * Creates a new {@link Dashboard} instance that allows you\n   * to embed a dashboard into your application\n   */\n\n\n  createDashboard(options) {\n    return new Dashboard({ ...this.defaultOptions,\n      ...options\n    });\n  }\n\n}\n\nexport default EmbedSDK;\nexport { getRealmUserToken };\n"]},"metadata":{},"sourceType":"module"}